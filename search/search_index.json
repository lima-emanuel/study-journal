{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Study Journal","text":"<p>This is a collection of notes on programming languages, frameworks and other computer science topics that I am writing to keep track of my studies. It is a work in progress.</p>"},{"location":"agile/","title":"Notes on Agile","text":""},{"location":"agile/#introduction","title":"Introduction","text":""},{"location":"ansible/","title":"Notes on Ansible","text":""},{"location":"ansible/#introduction","title":"Introduction","text":""},{"location":"aws/","title":"Notes on AWS","text":""},{"location":"aws/#storage","title":"Storage","text":""},{"location":"aws/#block-storage","title":"Block Storage","text":""},{"location":"aws/#file-storage","title":"File Storage","text":""},{"location":"aws/#object-storage","title":"Object Storage","text":""},{"location":"aws/#compute","title":"Compute","text":""},{"location":"aws/#networking","title":"Networking","text":""},{"location":"aws/#databases","title":"Databases","text":""},{"location":"aws/#cloud-ops","title":"Cloud Ops","text":""},{"location":"aws/#security","title":"Security","text":""},{"location":"aws/#serverless","title":"Serverless","text":""},{"location":"bash/","title":"Notes on Bash","text":""},{"location":"bash/#introduction","title":"Introduction","text":""},{"location":"c/","title":"Notes on C","text":""},{"location":"c/#basics","title":"Basics","text":"<p>The minimal \"hello world\" C program:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n</code></pre> <p>Any position that is not listed in the initializer is set to 0. A[2] == 0.0</p> <p>Don\u2019t compare to 0, false, or true. Also, all scalars have a truth value. An integer or floating point 0 will always evaluate to false.</p> <pre><code>// GOOD\nbool b = true;\nif ( b ) {\n  // do something\n}\n\n// BAD\nbool b = true;\nif (( b != false ) == true ) {\n  // do something\n}\n</code></pre> <p>The scalar types:</p> Name Where printf size_t \"%zu\" \"%zx double Built in \"%e\" \"%f\" \"%g\" \"%a\" signed Built in \"%d\" unsigned Built in \"%u\" \"%x\" bool \"%d\" ptrdiff_t \"%td\" char const* Built in \"%s\" char Built in \"%c\" void* Built in \"%p\" unsigned char Built in \"%hhu\" \"%02hhx\" <p>size_t is any integer on the interval [0, SIZE_MAX], as defined on stdint.h.</p> <p>Best Practice: Never modify more than one object in a statement.</p> <p>Best Practice: Never declare various pointers or arrays on the same line to avoid errors.</p> <p>Ternary operator:</p> <pre><code>// Pattern:\n// (boolean_expression) ? if_true : if_false;\n\nsize_t size_min(size_t a , size_t b) {\n    return ( a &lt; b ) ? a : b;\n}\n</code></pre> <p>Attention: in an expression such as <code>f(a) + g(b)</code>, there is no pre-established order specifying whether <code>f(a)</code> or <code>g(b)</code> is to be computed first. If either the function <code>f</code> or <code>g</code> works with side effects (for instance, if <code>f</code> modifies <code>b</code> behind the scenes), the outcome of the expression will depend on the chosen order. The same holds for function arguments:</p> <pre><code>printf(\"%g and %g\\n\", f(a), f(b));\n</code></pre> <p>Best Practice: Functions that are called inside expressions should not have side effects.</p> <p>Every type in C is either an object type or a function type.</p> <p>C is call-by-value. When you provide an argument to a function, the value of that argument is copied into a distinct variable for use within the function.</p> <p>Scopes can be nested, with inner and outer scopes. For example, you can have a block scope inside another block scope, and every block scope is defined within a file scope. The inner scope has access to the outer scope, but not vice versa. If you declare the same identifier in both the inner scope and an outer scope, the identifier declared in the outer scope is hidden by the identifier within the inner scope, which takes precedence. In this case, naming the identifier will refer to the object in the inner scope; the object from the outer scope is hidden and cannot be referenced by its name.</p> <p>Scope and lifetime are different. Scope applies to identifiers, whereas lifetime applies to objects. The scope of an identifier is the code region where the object denoted by the identifier can be accessed by its name. The lifetime of an object is the time period for which the object exists.</p> <p>Automatic lifetimes are declared within a block or as a function parameter. The lifetime of these objects begins when the block in which they\u2019re declared begins execution, and ends when execution of the block ends. If the block is entered recursively, a new object is created each time, each with its own storage.</p> <p>Objects declared in file scope have static storage duration. The lifetime of these objects is the entire execution of the program, and their stored value is initialized prior to program startup. One can use <code>static</code> to declare a variable within a block scope to have a static lifetime. These objects persist after the function has exited.</p> <p>Best Practice: Never declare functions with an empty parameter list in C. Always use <code>void</code> in the parameter like so:</p> <pre><code>int my_function(void);\n</code></pre>"},{"location":"c/#enums","title":"Enums","text":"<p>Allows you to define a type that assigns names (enumerators) to integer values in cases with an enumerable set of constant val- ues.</p> <pre><code>enum day { sun, mon, tue, wed, thu, fri, sat };\nenum cardinal_points { north = 0, east = 90, south = 180, west = 270 };\nenum months { jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };\n</code></pre>"},{"location":"c/#pointers","title":"Pointers","text":"<pre><code>int* ip;\nchar* cp;\nvoid* vp;\n\nint i = 17;\nint* ip = &amp;i;\n</code></pre> <p>The <code>&amp;</code> operator takes the address of an object or function. The <code>*</code> operator converts a pointer to a type into a value of that type. It denotes indirection and operates only on pointers.</p>"},{"location":"c/#arrays","title":"Arrays","text":"<p>A contiguously allocated sequence of objects that all have the same element type.</p> <pre><code>int ia[11];\nfloat* afp[17];\n\nint matrix[3][5];\n</code></pre> <p>Initializing an array:</p> <pre><code>double A[5] = {\n    [0] = 9.0,\n    [1] = 2.9,\n    [4] = 3.E+25,\n    [3] = .00007,\n};\n\n// A[2] is initialized as 0.0\n</code></pre>"},{"location":"c/#structs","title":"Structs","text":"<p>A struct contains sequentially allocated member objects. One can reference members of a struct by using the struct member operator (<code>.</code>). If you have a pointer to a struct, you can reference its members with the struct pointer operator (<code>-&gt;</code>).</p> <pre><code>typedef struct vec2 { float x, y; } vec2;\n\nvec2 v0 = {1.0f, 2.0f};\nvec2 v1 = {.x = 1.0f, .y = 2.0f};\nvec2 v2 = {.y = 2.0f};    // missing struct members are set to zero\n\n\n\n// Inside functions, runtime-variable values can be used for initialization:\nfloat get_x(void) {\n    return 1.0f;\n}\n\nvoid bla(void) {\n    vec2 v0 = { .x = get_x(), .y = 2.0f };\n}\n\n// But this doesn't work:\nvec2 v0;\n// this doesn't work\nv0 = {1.0f, 2.0f};\n// instead a type hint is needed:\nv0 = (vec2) {1.0f, 2.0f};\n</code></pre>"},{"location":"c/#unions","title":"Unions","text":"<p>Union types are similar to structures, except that the memory used by the member objects overlaps. Unions can contain an object of one type at one time, and an object of a different type at a different time, but never both objects at the same time, and are primarily used to save memory.</p>"},{"location":"c/#qualifiers","title":"Qualifiers","text":"<p>Types can be qualified by using one or more of the following qualifiers: const, volatile, and restrict.</p> <ul> <li><code>const</code>: not modifiable. Will be placed in read-only memory by the compiler, and any attempt to write to them will result in a runtime error.</li> <li><code>volatile</code>: values stored in these objects may change without the knowledge of the compiler. For example, every time the value from a real-time clock is read, it may change, even if the value has not been written to by the C program. Using a volatile-qualified type lets the compiler know that the value may change, and ensures that every access to the real-time clock occurs (\u00adotherwise, an access to the real-time clock may be optimized away or replaced by a previously read and cached value).</li> <li><code>restrict</code>: Used to promote optimization. Objects \u00adindirectly accessed through a pointer frequently cannot be fully optimized because of potential aliasing, which occurs when more than one pointer refers to the same object. Aliasing can inhibit optimizations, because the compiler can\u2019t tell if portions of an object can change values when another apparently unrelated object is modified, for example.</li> </ul>"},{"location":"c/#preprocessor","title":"Preprocessor","text":"<p>Defines a macro as 0 and an empty macro:</p> <pre><code>#define  __MACRO__ 0\n\n#define  __MACRO2__\n</code></pre> <p>Checks if a macro is defined. If it is, throws an error (the error stops the compilation):</p> <pre><code>#ifdef  __MACRO__\n#error \"Error!\"\n#endif\n</code></pre> <p>Checks if a macro is not defined. If it isn't, defines it:</p> <pre><code>#ifndef __MACRO__\n#define __MACRO__\n#endif\n</code></pre>"},{"location":"c/#some-best-practices","title":"Some Best Practices","text":"<ul> <li>Enable all warnings: -Wall and -Wextra on GCC and Clang</li> <li>Wrap your structs in a typedef:</li> </ul> <pre><code>typedef struct bla{\n    int a, b, c;\n} bla;\n\n// Attention: the POSIX standard reserves the \u2018_t\u2019 postfix for its own type names to prevent collisions with user types.\n</code></pre> <ul> <li>Use void to indicate that a function does not receive arguments:</li> </ul> <pre><code>// GOOD\nvoid my_func(void) {\n    ...\n}\n\n// BAD\nvoid my_func() {\n    ...\n}\n</code></pre> <ul> <li>Don\u2019t be afraid to pass and return structs by value:</li> </ul> <pre><code>typedef struct float2{ float x, y; } float2;\n\nfloat2 addf2(float2 v0, float2 v1) {\n    return (float2) { v0.x + v1.x, v0.y + v1.y };\n}\n\n...\nfloat2 v0 = {1.0f, 2.0f};\nfloat2 v1 = {3.0f, 4.0f};\nfloat2 v3 = addf2(v0, v1);\n...\n\n// You can also move the initialization of the two inputs right into the function call:\nfloat2 v3 = addf2((float2){ 1.0f, 2.0f }, (float2){ 3.0f, 4.0f });\n</code></pre>"},{"location":"c/#some-headers","title":"Some Headers","text":"<ul> <li>stdint.h: defines integer types with certain widths.</li> <li>tgmath.h: defines type generic math functions, for both real and complex numbers.</li> </ul>"},{"location":"c/#bibliography","title":"Bibliography","text":"<ul> <li>SEACORD, Robert. Effective C: an introduction to professional C programming. No Starch Press. 2020.</li> </ul>"},{"location":"cpp/","title":"Notes on C++","text":""},{"location":"cpp/#basics","title":"Basics","text":"<p>The minimal \"hello world\" C++ program:</p> <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    std::cout&lt;&lt;\"Hello, World!\\n\";\n    return 0;\n}\n</code></pre> <p>The #include directive imports a library to be used. The main function is the entry point of the program and returns an integer upon successful completion. Blocks of code that perform some well defined action should be encapsulated on a function. That function would then be called on main(). A function must be declared before being used. The declaration follows this syntax:</p> <pre><code>Node* next_node();     // Receives no argument, returns pointer to Node\nvoid call_number(int); // Receives an int, returns nothing\ndouble exp(double);    // Receives a double, returns a double.\n</code></pre> <p>There can be more than one argument. The types of the arguments and of the return are checked at compile time. The code that makes up a software must be comprehensible because this is the first step to maintainability. To make code more comprehensible, we must divide its tasks into functions. That way, we will have a basic vocabulary for data (types, both built-in and user defined) and for actions on that data (functions). Encapsulating a specific action into a function, forces us to not repeat ourselves (DRY) and to document that action's dependencies. If a function with the same name is declared with different arguments, the compiler will accept all of them and use the function corresponding to the type used. This allows us to change the behavior of an action based on the type of the data we are dealing with. Attention to the fact that the declarations cannot be ambiguous. If so, the compiler will throw an error. Another point is that if a set of functions have the same name, they should have the same semantics, i.e., they should perform the same action. Example:</p> <pre><code>// This is called function overloading\nvoid sum(int, int);\nvoid sum(double, double);\n\nvoid use()\n{\n  sum(2, 2);\n  sum(2.7, 3.14);\n}\n</code></pre> <p>Every object in the language has a type. An object is a portion of memory that holds a value of the given type. A value is a set of bits that are interpreted according to the type. Some built-in types are bool, char, int and double. Int variables' representation default to decimal (42) but can also be declared as binary (0b1010), hexadecimal (0x04AF) or octal (0432). The usual arithmetic, comparison, logical and modification operations are present:</p> Arithmetic Comparison Logical Modification x + y x == y x &amp;&amp; y x += y x - y x != y x || y x -= y x * y x &lt; y !x ++x x / y x &gt; y --x x % y x &lt;= y x *= y x &gt;= y x /= y x %= y <p>Attention to the fact that C++ makes implicit conversion on basic types:</p> <pre><code>void my_function()\n{\n  double d = 3.14;\n  int i = 5;\n  d = d + i; // d is 8.14 here\n  i = d * i; // i is 15 here.\n  // The resulting multiplication is 15.7,\n  // but the value is truncated to fit an int\n}\n</code></pre> <p>There are two forms of variable initialization, \"=\" or \"{}\":</p> <pre><code>double d = 3.14;\ndouble d2 {2.7};\n\n// Vector of ints\nvector&lt;int&gt; v {1, 2, 3};\n</code></pre> <p>The \"=\" is a tradition from C. \"{}\" is preferred because it avoids implicit conversions:</p> <pre><code>int a = 4.8; // a is 4 here\nint b {4.8}; // Error\n</code></pre> <p>If the data is coming from the user, for example, implicit conversions are a recipe for disaster, if not checked. The type of a variable can be deduced by the compiler with the \"auto\" keyword. My opinion is that auto should only be used when the types are very long (as they usually are with templates). Explicit (short) types help with code readability.</p> <pre><code>auto a = 4.8;\nauto b {4.8}; // Both a and b are double\n</code></pre> <p>-&gt; 1.5</p>"},{"location":"cpp/#user-defined-types","title":"User-Defined Types","text":""},{"location":"cpp/#modularity","title":"Modularity","text":""},{"location":"cpp/#classes","title":"Classes","text":""},{"location":"cpp/#constructors","title":"Constructors","text":"<p>A constructor without parameters or with default parameters set is called a default constructor. It is a constructor which can be called without arguments:</p> <pre><code>class MyClass\n{\n  public:\n    MyClass()\n    {\n      std::cout &lt;&lt; \"Default constructor invoked.\\n\";\n    }\n};\n\nint main()\n{\n  MyClass o; // invoke a default constructor\n}\n\n// Default arguments\nclass MyClass\n{\n  public:\n    MyClass(int x = 123, int y = 456)\n    {\n      std::cout &lt;&lt; \"Default constructor invoked.\\n\";\n    }\n};\n\nint main()\n{\n  MyClass o; // invoke a default constructor\n}\n\n// If a default constructor is not explicitly defined in the code, the compiler will generate a default constructor.\n// Constructors are invoked when object initialization takes place. They can\u2019t be invoked directly.\n</code></pre> <p>Member initializer list:</p> <pre><code>class MyClass\n{\n public:\n   int x, y;\n   MyClass(int xx, int yy)\n     : x{ xx }\n     , y{ yy } // member initializer list\n   {\n   }\n};\n\nint main()\n{\n   MyClass o{ 1, 2 }; // invoke a user-defined constructor\n   std::cout &lt;&lt; o.x &lt;&lt; ' ' &lt;&lt; o.y;\n}\n</code></pre>"},{"location":"cpp/#copy-constructors","title":"Copy Constructors","text":"<p>When we initialize an object with another object of the same class, we invoke a copy constructor. If we do not supply our copy constructor, the compiler generates a default copy constructor.</p> <pre><code>class MyClass\n{\n  private:\n    int x, y;\n\n  public:\n    MyClass(int xx, int yy) : x{ xx }, y{ yy }\n    {\n    }\n};\nint main()\n{\n  MyClass o1{ 1, 2 };\n  MyClass o2 = o1; // default copy constructor invoked\n}\n</code></pre> <p>A user defined copy constructor has this signature: <code>MyClass(const MyClass&amp; rhs)</code></p> <pre><code>class MyClass\n{\n  private:\n    int x, y;\n\n  public:\n    MyClass(int xx, int yy) : x{ xx }, y{ yy }\n    {\n    }\n\n    MyClass(const MyClass&amp; rhs)\n    : x { rhs.x }\n    , y { rhs.y }\n    {\n    }\n};\nint main()\n{\n  MyClass o1{ 1, 2 };\n  MyClass o2 = o1; // user copy constructor invoked\n}\n</code></pre>"},{"location":"cpp/#copy-assignment","title":"Copy Assignment","text":"<p>When an object is created on one line and then assigned to in the next line, it then uses the copy assignment operator to copy the data from another object:</p> <pre><code>MyClass from, to;\nto = from; // copy assignment\n</code></pre> <p>A copy assignment operator is of the following signature: <code>MyClass&amp; operator=(const MyClass&amp; rhs)</code></p> <pre><code>class MyClass\n{\n  public:\n    MyClass&amp; operator=(const MyClass&amp; rhs)\n    {\n      // implement the copy logic here\n      return *this;\n    }\n};\n\n// The overloaded = operators must return a dereferenced this pointer at the end.\n</code></pre>"},{"location":"cpp/#move-constructor","title":"Move Constructor","text":"<p>We can move the data from one object to the other. We call it a move semantics.</p>"},{"location":"cpp/#operations","title":"Operations","text":""},{"location":"cpp/#templates","title":"Templates","text":""},{"location":"cpp/#generic-programming","title":"Generic Programming","text":""},{"location":"cpp/#standard-library","title":"Standard Library","text":""},{"location":"cpp/#strings-and-regex","title":"Strings and Regex","text":"<p>To accept a string from standard input, use <code>std::getline(read_from, into)</code>:</p> <pre><code>std::string s;\nstd::cout &lt;&lt; \"Enter string: \";\nstd::getline(std::cin, s);\n</code></pre> <p>To create a substring from a string, use the method <code>.substring(starting_index, length)</code>:</p> <pre><code>std::string s = \"Hello World\";\nstd::string sub_s = s.substr(6, 5);\n</code></pre> <p>To find a substring in a given string, use the method <code>.find()</code>. If the method finds, it returns the position of the first found substring (the index of the first char of the substring). If the method doesn't find, it returns <code>std::string:npos</code>. The return type of the function is <code>std::string::size_type</code>:</p> <pre><code>std::string s = \"Hello World\";\nstd::string search_for = \"World\";\nstd::string::size_type found = s.find(search_for);\n</code></pre>"},{"location":"cpp/#io","title":"I/O","text":"<p>TODO</p>"},{"location":"cpp/#containers","title":"Containers","text":"<p>TODO</p>"},{"location":"cpp/#algorithms","title":"Algorithms","text":"<p>TODO</p>"},{"location":"cpp/#utilities","title":"Utilities","text":"<p>TODO</p>"},{"location":"cpp/#numerics","title":"Numerics","text":"<p>TODO</p>"},{"location":"cpp/#concurrency","title":"Concurrency","text":"<p>TODO</p>"},{"location":"cpp/#references","title":"References","text":"<ul> <li>Bjarne Stroustrup. A Tour of C++. Pearson Education. 2018.</li> <li>Slobodan Dmitrovic. Modern C++ for Absolute Beginners. 2020.</li> </ul>"},{"location":"cython/","title":"Notes on Cython","text":""},{"location":"cython/#compilation","title":"Compilation","text":""},{"location":"cython/#using-distutils-with-cythonize","title":"Using distutils with cythonize","text":"<p>Consider a <code>fib.pyx</code> Cython source code. Our goal is to use distutils to create a compiled extension module (<code>fib.so</code> on Mac OS X or Linux and <code>fib.pyd</code> on Windows). For that, we use a <code>setup.py</code> file like so:</p> <pre><code>from distutils.core import setup\nfrom Cython.Build import cythonize\n\nsetup(name='Fibonacci App',\n      ext_modules=cythonize('fib.pyx',\n                            nthreads=4,\n                            force=False,\n                            annotate=True,\n                            compiler_directives={'binding': True},\n                            language_level=\"3\"))\n</code></pre> <p>The arguments of the function <code>cythonize</code> can be seen here. The most important ones are explained below:</p> <ul> <li>The first argument is the name of the Cython files. It can also be a glob pattern such as <code>src/*.pyx</code>;</li> <li><code>nthreads</code>: The number of concurrent builds for parallel compilation (requires the multiprocessing module);</li> <li><code>force</code>: Forces the recompilation of the Cython modules, even if the timestamps don\u2019t indicate that a recompilation is necessary. Default is False;</li> <li><code>annotate</code>: If True, will produce a HTML file for each of the .pyx or .py files compiled. The HTML file gives an indication of how much Python interaction there is in each of the source code lines, compared to plain C code. It also allows you to see the C/C++ code generated for each line of Cython code. Default is False;</li> <li><code>compiler_directives</code>: Allows to set compiler directives. More information here;</li> <li><code>language_level</code>: The level of the Python language. <code>3</code> is for Python 3.</li> </ul> <p>These two function calls succinctly demonstrate the two stages in the pipeline: cythonize calls the cython compiler on the .pyx source file or files, and setup compiles the generated C or C++ code into a Python extension module. A C compiler, such as <code>gcc</code>, <code>clang</code> or <code>MSVC</code> is necessary at compile time.</p> <p>To build on Linux and MacOS, run:</p> <pre><code>python3 setup.py build_ext --inplace\n</code></pre> <p>The build_ext argument is a command instructing distutils to build the Extension object or objects that the cythonize call created. The optional --inplace flag instructs distutils to place each extension module next to its respective Cython .pyx source file.</p> <p>On Windows:</p> <pre><code>python setup.py build_ext --inplace --compiler=msvc\n</code></pre> <p>If you use setuptools instead of distutils, the default action when running <code>python3 setup.py install</code> is to create a zipped egg file which will not work with cimport for pxd files when you try to use them from a dependent package. To prevent this, include zip_safe=False in the arguments to setup().</p> <p>One can also set compiler options in the <code>setup.py</code>, before calling <code>cythonize()</code>, like so:</p> <pre><code>from distutils.core import setup\nfrom Cython.Build import cythonize\n\nfrom Cython.Compiler import Options\n\nOptions.embed = True\n\nsetup(name='Fibonacci App',\n      ext_modules=cythonize('fib.pyx',\n                            nthreads=4,\n                            force=False,\n                            annotate=True,\n                            compiler_directives={'binding': True},\n                            language_level=\"3\"))\n</code></pre> <p>The <code>embed</code> option embeds the Python interpreter, in order to make a standalone executable. This will provide a C function which initialises the interpreter and executes the body of this module. More options here.</p>"},{"location":"cython/#typing","title":"Typing","text":""},{"location":"cython/#typing-variables","title":"Typing variables","text":"<p>Untyped dynamic variables are declared and behave exactly like Python variables:</p> <pre><code>a = 42\n</code></pre> <p>Statically typed variables are declared like so:</p> <pre><code>cdef int a = 42\ncdef size_t len\ncdef double *p\ncdef int arr[10]\n</code></pre> <p>and behave like C variables.</p> <p>It is possible to mix both kinds of variables if there is a trivial correspondence between the types, like C and Python ints:</p> <pre><code># C variables\ncdef int a, b, c\n\n# Calculations using a, b, and c...\n\n# Inside a Python tuple\ntuple_of_ints = (a, b, c)\n</code></pre> <p>In Python 3, all <code>int</code> objects have unlimited precision. When converting integral types from Python to C, Cython generates code that checks for overflow. If the C type cannot represent the Python integer, a runtime OverflowError is raised. A Python <code>float</code> is stored as a C <code>double</code>. Converting a Python <code>float</code> to a C <code>float</code> may truncate to 0.0 or positive or negative infinity, according to IEEE 754 conversion rules. The Python complex type is stored as a C struct of two doubles. Cython has float complex and double complex C-level types, which correspond to the Python complex type.</p> <p>We can also use <code>cdef</code> to statically declare variables with a Python type. We can do this for the built-in types like <code>list</code>, <code>tuple</code>, and <code>dict</code> and extension types like NumPy arrays:</p> <pre><code>cdef list particles, modified_particles\ncdef dict names_from_particles\ncdef str pname\ncdef set unique_particles\n</code></pre> <p>The more static type information we provide, the better Cython can optimize the result.</p>"},{"location":"cython/#c-functions","title":"C Functions","text":"<p>When used to define a function, the cdef keyword creates a function with C-calling semantics. A cdef function\u2019s arguments and return type are typically statically typed, and they can work with C pointer objects, structs, and other C types that cannot be automatically coerced to Python types. It is helpful to think of a cdef function as a C function that is defined with Cython\u2019s Python-like syntax.</p> <pre><code>cdef long factorial(long n):\n    if n &lt;= 1:\n        return 1\n    return n * factorial(n - 1)\n</code></pre> <p>A function declared with <code>cdef</code> can be called by any other function (<code>def</code> or <code>cdef</code>) inside the same Cython source file. However, Cython does not allow a <code>cdef</code> function to be called from external Python code. Because of this restriction, <code>cdef</code> functions are typically used as fast auxiliary functions to help <code>def</code> functions do their job. If we want to use <code>factorial</code> from Python code outside of this extension module, we need a minimal def function that calls <code>factorial</code> internally:</p> <pre><code>def wrap_factorial(n):\n    return factorial(n)\n</code></pre> <p>One limitation of this is that <code>wrap_factorial</code> and its underlying <code>factorial</code> are restricted to C integral types only, and do not have the benefit of Python\u2019s unlimited-precision integers. This means that <code>wrap_factorial</code> gives erroneous results for arguments larger than some small value, depending on how large an <code>unsigned long</code> is on your system. We always have to be aware of the limitations of the C types.</p>"},{"location":"cython/#c-functions-with-automatic-python-wrappers","title":"C Functions with Automatic Python Wrappers","text":"<p>A <code>cpdef</code> function combines features from <code>cdef</code> and <code>def</code> functions: we get a C-only version of the function and a Python wrapper for it, both with the same name. When we call the function from Cython, we call the C-only version; when we call the function from Python, the wrapper is called.</p> <pre><code>cpdef long factorial(long n):\n    if n &lt;= 1:\n        return 1\n    return n * factorial(n - 1)\n</code></pre> <p>A <code>cpdef</code> function has one limitation, due to the fact that it does double duty as both a Python and a C function: its arguments and return types have to be compatible with both Python and C types.</p> <p>Both <code>cdef</code> and <code>cpdef</code> can be given an <code>inline</code> hint that the C compiler can use or ignore, depending on the situation:</p> <pre><code>cpdef inline long factorial(long n):\n    if n &lt;= 1:\n        return 1\n    return n * factorial(n - 1)\n</code></pre> <p>The <code>inline</code> modifier, when judiciously used, can yield performance improvements, especially for small inlined functions called in deeply nested loops, for example.</p>"},{"location":"cython/#exception-handling","title":"Exception Handling","text":"<p>A <code>def</code> function always returns some sort of PyObject pointer at the C level. This invariant allows Cython to correctly propagate exceptions from def functions without issue. Cython\u2019s other two function types (<code>cdef</code> and <code>cpdef</code>) may return a non-Python type, which makes some other exception-indicating mechanism necessary. Example:</p> <pre><code>cpdef int divide_ints(int i, int j):\n    return i / j\n</code></pre> <p>To correctly propagate the exception that occurs when j is 0, Cython provides an <code>except</code> clause:</p> <pre><code>cpdef int divide_ints(int i, int j) except? -1:\n    return i / j\n</code></pre> <p>The <code>except? -1</code> clause allows the return value -1 to act as a possible sentinel that an exception has occurred. If <code>divide_ints</code> ever returns -1, Cython checks if the global exception state has been set, and if so, starts unwinding the stack. In this example we use a question mark in the <code>except</code> clause because -1 might be a valid result from <code>divide_ints</code>, in which case no exception state will be set. If there is a return value that always indicates an error has occurred without ambiguity, then the question mark can be omitted.</p>"},{"location":"cython/#c-structs-unions-enums-an-typedefs","title":"C structs, unions, enums an typedefs","text":"<p>The following C constructs:</p> <pre><code>struct mycpx {\n    int a;\n    float b;\n};\n\nunion uu {\n    int a;\n    short b, c;\n};\n\nenum COLORS {ORANGE, GREEN, PURPLE};\n</code></pre> <p>Can be declared on Cython like this:</p> <pre><code>cdef struct mycpx:\n    float real\n    float imag\n\ncdef union uu:\n    int a\n    short b, c\n\ncdef enum COLORS:\n    ORANGE, GREEN, PURPLE\n</code></pre> <p>We can combine <code>struct</code> and <code>union</code> declarations with <code>ctypedef</code>, which creates a new type alias for the <code>struct</code> or <code>union</code>:</p> <pre><code>ctypedef struct mycpx:\n    float real\n    float imag\n\nctypedef union uu:\n    int a\n    short b, c\n</code></pre> <p>To declare and initialize:</p> <pre><code>cdef mycpx a = mycpx(3.1415, -1.0)\n\n# Or\ncdef mycpx b = mycpx(real=2.718, imag=1.618034)\n\n# Or\ncdef mycpx zz\nzz.real = 3.1415\nzz.imag = -1.0\n\n# Or, structs can be assigned from a Python dictionary (with CPython overhead):\ncdef mycpx zz = {'real': 3.1415, 'imag': -1.0}\n</code></pre>"},{"location":"cython/#efficient-loops","title":"Efficient Loops","text":"<p>Considering this Python for loop over a range:</p> <pre><code>n = 100\n# ...\nfor i in range(n):\n    # ...\n</code></pre> <p>Its cythonized version that would produce the best performing C code is:</p> <pre><code>cdef unsigned int i, n = 100\nfor i in range(n):\n    # ...\n</code></pre>"},{"location":"cython/#extension-types","title":"Extension Types","text":"<p>A Python class such as:</p> <pre><code>class Particle():\n    def __init__(self, m, p, v):\n        self.mass = m\n        self.position = p\n        self.velocity = v\n    def get_momentum(self):\n        return self.mass * self.velocity\n</code></pre> <p>Would be cythonized as:</p> <pre><code>cdef class Particle():\n    cdef double mass, position, velocity\n\n    def __init__(self, m, p, v):\n        self.mass = m\n        self.position = p\n        self.velocity = v\n    def get_momentum(self):\n        return self.mass * self.velocity\n</code></pre> <p>To make an attribute readonly (for a Python caller):</p> <pre><code>cdef class Particle():\n    cdef readonly double mass\n    cdef double position, velocity\n# ...\n</code></pre> <p><code>mass</code> will be readable and not writable by the Python caller, but <code>position</code> and <code>velocity</code> will be completely private.</p> <pre><code>cdef class Particle():\n    cdef readonly double mass\n    cdef public double position\n    cdef double velocity\n# ...\n</code></pre> <p>Here, <code>position</code> will be both readable and writable by the Python caller. If C-level allocations and deallocations must occur, then use the <code>__cinit__</code> and <code>__dealloc__</code> methods:</p> <pre><code>cdef class Matrix:\n    cdef:\n        unsigned int nrows, ncols\n        double *_matrix\n\n    def __cinit__(self, nr, nc):\n        self.nrows = nr\n        self.ncols = nc\n        self._matrix = &lt;double*&gt;malloc(nr * nc * sizeof(double))\n        if self._matrix == NULL:\n            raise MemoryError()\n\n    def __dealloc__(self):\n        if self._matrix != NULL:\n        free(self._matrix)\n</code></pre> <p>You can cast a Python object to a static object:</p> <pre><code># p is a Python object that may be a Particle\n\ncdef Particle static_p = p\n\n# Or, with the possibility of segfault if p is not a particle:\n\n&lt;Particle&gt;p\n\n# Or, safelly, but with overhead:\n\n&lt;Particle?&gt;p\n</code></pre> <p><code>None</code> can be passed as argument for functions that receive static type. This will lead to segfaults. To protect against it:</p> <pre><code>def dispatch(Particle p not None):\n    print p.get_momentum()\n    print p.velocity\n</code></pre>"},{"location":"cython/#wrapping-c","title":"Wrapping C++","text":"<p>TODO</p>"},{"location":"cython/#profiling","title":"Profiling","text":"<p>TODO</p>"},{"location":"cython/#typed-memoryviews","title":"Typed Memoryviews","text":"<p>TODO</p>"},{"location":"cython/#parallelism","title":"Parallelism","text":"<p>TODO</p>"},{"location":"cython/#references","title":"References","text":"<ul> <li>Kurt W. Smith. Cython. 1st Edition. O\u2019Reilly.</li> <li>Official Cython\u2019s Documentation</li> </ul>"},{"location":"go/","title":"Notes on Go","text":""},{"location":"go/#basics","title":"Basics","text":""},{"location":"go/#packages","title":"Packages","text":"<p>Programs start running in package <code>main</code>. Syntax for imports is:</p> <pre><code>import (\n    \"fmt\"\n    \"math/rand\"\n)\n</code></pre> <p>the <code>math/rand</code> package comprises files that begin with the statement <code>package rand</code>.</p> <p>A name is exported if it begins with a capital letter. For example, Pi is an exported name, which is exported from the <code>math</code> package. Usage like so:</p> <pre><code>import (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(math.Pi)\n}\n</code></pre>"},{"location":"go/#functions","title":"Functions","text":"<p>f</p> <p>Syntax:</p> <pre><code>func add(x int, y int) int {\n    return x + y\n}\n</code></pre> <p>When two or more consecutive named function parameters share a type, you can omit the type from all but the last. So it becomes:</p> <pre><code>func add(x, y int) int {\n    return x + y\n}\n\n// Using:\nfunc main() {\n    fmt.Println(add(42, 13))\n}\n</code></pre> <p>A function can return any number of results:</p> <pre><code>func swap(x, y string) (string, string) {\n    return y, x\n}\n\n// Using:\nfunc main() {\n    a, b := swap(\"hello\", \"world\")\n}\n</code></pre> <p>Return values may be named. If so, they are treated as variables defined at the top of the function. A return statement without arguments returns the named return values. This is known as a \"naked\" return.</p> <pre><code>func split(sum int) (x, y int) {\n    x = sum * 4 / 9\n    y = sum - x\n    return\n}\n</code></pre>"},{"location":"go/#types","title":"Types","text":"<p><code>var</code> statement declares a list of variables; as in function argument lists, the type is last. A <code>var</code> statement can be at package or function level.</p> <pre><code>import \"fmt\"\n\nvar c, python, java bool\n\nfunc main() {\n    var i int\n    fmt.Println(i, c, python, java)\n}\n</code></pre> <p>A <code>var</code> declaration can include initializers, one per variable. If an initializer is present, the type can be omitted; the variable will take the type of the initializer.</p> <pre><code>var i, j int = 1, 2\n\nfunc main() {\n    var c, python, java = true, false, \"no!\"\n    fmt.Println(i, j, c, python, java)\n}\n</code></pre> <p>Inside a function, the <code>:=</code> short assignment statement can be used in place of a var declaration with implicit type. Outside a function, every statement begins with a keyword and so the <code>:=</code> construct is not available.</p> <pre><code>func main() {\n    var i, j int = 1, 2\n    k := 3\n    c, python, java := true, false, \"no!\"\n\n    fmt.Println(i, j, k, c, python, java)\n}\n</code></pre> <p>Basic types:</p> <pre><code>bool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // alias for uint8\n\nrune // alias for int32\n     // represents a Unicode code point\n\nfloat32 float64\n\ncomplex64 complex128\n</code></pre> <p>Can also be initialized like so:</p> <pre><code>import (\n    \"fmt\"\n    \"math/cmplx\"\n)\n\nvar (\n    ToBe   bool       = false\n    MaxInt uint64     = 1&lt;&lt;64 - 1\n    z      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n    fmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\n    fmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\n    fmt.Printf(\"Type: %T Value: %v\\n\", z, z)\n}\n</code></pre> <p>Variables declared without an explicit initial value are given their zero value. The zero value is:</p> <ul> <li><code>0</code> for numeric types,</li> <li><code>false</code> for the boolean type, and</li> <li><code>\"\"</code> (the empty string) for strings.</li> </ul> <p>Assignment between items of different type requires an explicit conversion:</p> <pre><code>i := 42\nf := float64(i)\nu := uint(f)\n</code></pre> <p>Constants are declared like variables, but with the const keyword. They can be character, string, boolean, or numeric values. Constants cannot be declared using the := syntax.</p> <pre><code>const Pi = 3.14\n\nfunc main() {\n    const World = \"\u4e16\u754c\"\n    fmt.Println(\"Hello\", World)\n    fmt.Println(\"Happy\", Pi, \"Day\")\n\n    const Truth = true\n    fmt.Println(\"Go rules?\", Truth)\n}\n</code></pre> <p>A pointer holds the memory address of a value.</p> <pre><code>// Type *T is a pointer to a T value. Its zero value is nil.\nvar p *int\n\n// The &amp; operator generates a pointer to its operand.\ni := 42\np = &amp;i\n\n// The * operator denotes the pointer's underlying value.\n// This is known as dereferencing.\nfmt.Println(*p) // read i through the pointer p\n*p = 21         // set i through the pointer p\n</code></pre> <p>Structs:</p> <pre><code>type Vertex struct {\n    X int\n    Y int\n}\n\nvar (\n    v1 = Vertex{1, 2}  // has type Vertex\n    v2 = Vertex{X: 1}  // Y:0 is implicit\n    v3 = Vertex{}      // X:0 and Y:0\n    p  = &amp;Vertex{1, 2} // has type *Vertex\n)\n\nfunc main() {\n    v := Vertex{1, 2}\n    v.X = 4\n    fmt.Println(v.X)\n}\n</code></pre> <p>Struct fields can be accessed through a struct pointer:</p> <pre><code>type Vertex struct {\n    X, Y int\n}\n\nfunc main() {\n    v := Vertex{1, 2}\n    p := &amp;v // p is a pointer to v\n    p.X = 1e9 // dereferencing here\n    fmt.Println(v.X)\n}\n</code></pre> <p>The type <code>[n]T</code> is an array of <code>n</code> values of type <code>T</code>:</p> <pre><code>var a [2]string\na[0] = \"Hello\"\na[1] = \"World\"\n\nprimes := [6]int{2, 3, 5, 7, 11, 13}\n</code></pre> <p>An array's length is part of its type, so arrays cannot be resized.</p> <p>A slice is a dynamically-sized, flexible view into the elements of an array:</p> <pre><code>primes := [6]int{2, 3, 5, 7, 11, 13}\n\n// The type []T is a slice with elements of type T.\n// A slice is formed by specifying two indices, a low and high bound, separated by a colon.\n// This includes the first element, but excludes the last one.\nvar s []int = primes[1:4]\n\n// Changing the elements of a slice modifies the corresponding elements of its underlying array.\n// Other slices that share the same underlying array will see those changes.\n</code></pre> <p>Slice literals build and array literal and reference it:</p> <pre><code>q := []int{2, 3, 5, 7, 11, 13}\n\nr := []bool{true, false, true, true, false, true}\n\ns := []struct {\n    i int\n    b bool\n}{\n    {2, true},\n    {3, false},\n    {5, true},\n    {7, true},\n    {11, false},\n    {13, true},\n}\n</code></pre> <p>When slicing, you may omit the high or low bounds to use their defaults instead. The default is zero for the low bound and the length of the slice for the high bound.</p> <p>A slice has both a length and a capacity. The length of a slice is the number of elements it contains. The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice. The length and capacity of a slice s can be obtained using the expressions <code>len(s)</code> and <code>cap(s)</code>.</p> <pre><code>s := []int{2, 3, 5, 7, 11, 13}\n\n// Slice the slice to give it zero length.\ns = s[:0]\n\n// Extend its length.\ns = s[:4]\n\n// Drop its first two values.\ns = s[2:]\n</code></pre> <p>The zero value of a slice is nil. A <code>nil</code> slice has a length and capacity of 0 and has no underlying array.</p>"},{"location":"go/#control-flow","title":"Control Flow","text":"<p><code>For</code> is the only loop available:</p> <pre><code>func main() {\n    sum := 0\n    for i := 0; i &lt; 10; i++ {\n        sum += i\n }\n fmt.Println(sum)\n}\n\n// Or\n\nfunc main() {\n    sum := 1\n    for sum &lt; 1000 {\n        sum += sum\n }\n fmt.Println(sum)\n}\n\n// Infinite loop\nfor {\n}\n</code></pre> <p>Conditional:</p> <pre><code>func sqrt(x float64) string {\n    if x &lt; 0 {\n      return sqrt(-x) + \"i\"\n    }\n    return fmt.Sprint(math.Sqrt(x))\n}\n\n// The if statement can start with a short statement to execute before the condition.\n// Variables declared by the statement are only in scope until the end of the if.\nfunc pow(x, n, lim float64) float64 {\n    if v := math.Pow(x, n); v &lt; lim {\n     return v\n    }\n    return lim\n}\n\n// Variables declared inside an if short statement are also available inside any of the else blocks.\nfunc pow(x, n, lim float64) float64 {\n    if v := math.Pow(x, n); v &lt; lim {\n        return v\n    } else {\n        fmt.Printf(\"%g &gt;= %g\\n\", v, lim)\n    }\n    // can't use v here, though\n    return lim\n}\n\n// Switch cases evaluate cases from top to bottom, stopping when a case succeeds.\nfmt.Print(\"Go runs on \")\nswitch os := runtime.GOOS; os {\ncase \"darwin\":\n    fmt.Println(\"macOS.\")\ncase \"linux\":\n    fmt.Println(\"Linux.\")\ndefault:\n    fmt.Printf(\"%s.\\n\", os)\n}\n\n// Switch without a condition is the same as switch true.\n// This construct can be a clean way to write long if-then-else chains.\nt := time.Now()\nswitch {\ncase t.Hour() &lt; 12:\n    fmt.Println(\"Good morning!\")\ncase t.Hour() &lt; 17:\n    fmt.Println(\"Good afternoon.\")\ndefault:\n    fmt.Println(\"Good evening.\")\n}\n</code></pre> <p>A defer statement defers the execution of a function until the surrounding function returns. The call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.</p> <pre><code>func main() {\n    defer fmt.Println(\"world\")\n\n    fmt.Println(\"hello\")\n}\n</code></pre> <p>Deferred function calls are pushed onto a stack. When a function returns, its deferred calls are executed in last-in-first-out order.</p>"},{"location":"go/#methods-and-interfaces","title":"Methods and Interfaces","text":"<p>f</p>"},{"location":"go/#generics","title":"Generics","text":"<p>f</p>"},{"location":"go/#concurrency","title":"Concurrency","text":"<p>f</p>"},{"location":"go/#testing","title":"Testing","text":"<p>f</p>"},{"location":"go/#reflection","title":"Reflection","text":"<p>f</p>"},{"location":"go/#low-level","title":"Low Level","text":"<p>f</p>"},{"location":"intro/","title":"Introduction","text":"<p>This is a collection of notes on programming languages, frameworks and other computer science topics that I am writing to keep track of my studies. It is a work in progress.</p>"},{"location":"jl/","title":"Notes on Julia","text":""},{"location":"jl/#basics","title":"Basics","text":"<p>Julia is a high-level, general-purpose dynamic programming language, most commonly used for numerical analysis and computational science. Distinctive aspects of Julia's design include a type system with parametric polymorphism and the use of multiple dispatch as a core programming paradigm, efficient garbage collection, and a just-in-time (JIT) compiler (with support for ahead-of-time compilation).</p> <p>The minimal \"hello world\" program:</p> <pre><code># Single line comment\n\n#=\nMulti-line comment\n=#\n\nprintln(\"Hello, World!\")\n</code></pre> <p>Indentation doesn't matter. Indexing starts at 1, like Matlab and Octave. In the REPL, by pressing \"]\" you can enter the \"package mode\", where you can write commands that manage the packages you have or want. Some commands:</p> <ul> <li><code>status</code>: Retrieves a list with name and versions of locally installed packages</li> <li><code>update</code>: Updates your local index of packages and all your local packages to the latest version</li> <li><code>add myPkg</code>: Automatically downloads and installs a package</li> <li><code>rm myPkg</code>: Removes a package and all its dependent packages that has been installed automatically only for it</li> <li><code>add pkgName#master</code>: Checkouts the master branch of a package (and free pkgName returns to the released version)</li> <li><code>add pkgName#branchName</code>: Checkout a specific branch</li> <li><code>add git@github.com:userName/pkgName.jl.git</code>: Checkout a non registered pkg</li> </ul> <p>To use a package on a Julia script, write <code>using [package]</code> at the beginning of the script. To use a package without populating the namespace, write <code>import [package]</code>. But then, you will have to use the functions as <code>[package].function()</code>. You can also include local Julia scripts as such: <code>include(\"my_script.jl\")</code>.</p> <p>I think that <code>using [package]</code> is bad practice because it pollutes the namespace. The best way to import a package is this:</p> <pre><code># Importing the JSON package through an alias\nimport JSON as J\n\n# Using:\nJ.print(Dict(\"Hello, \" =&gt; \"World!\"))\n</code></pre> <p>A particular class of variable names is one that contains only underscores. These identifiers can only be assigned values, which are immediately discarded, and cannot therefore be used to assign values to other variables (i.e., they cannot be used as rvalues) or use the last value assigned to them in any way.</p>"},{"location":"jl/#data-types-and-structures","title":"Data Types and Structures","text":"<p>Some built-in data types and structures of the Julia language:</p>"},{"location":"jl/#scalar-types","title":"Scalar Types","text":"<p>The usual scalar types are present: Int64, UInt128, BigInt, Float64, Char and Bool.</p>"},{"location":"jl/#const-values","title":"Const values","text":"<p>Constant values are declared as such:</p> <pre><code>const foo = 1234\n</code></pre>"},{"location":"jl/#basic-math","title":"Basic Math","text":"<p>Complex numbers can be defined like so, with <code>im</code> being the square root of -1:</p> <pre><code>a = 1 + 2im\n</code></pre> <p>Exact integer division can be done like this:</p> <pre><code>a = 2 // 3\n</code></pre> <p>All standard basic mathematical arithmetic operators are supported (+, -, *, /, %, ^). Mathematical constants can be used like so:</p> <pre><code>MathConstants.e\nMathConstants.pi\n</code></pre> <p>Natural exponentiation can be done like this:</p> <pre><code> a = exp(b)\n</code></pre>"},{"location":"jl/#strings","title":"Strings","text":"<p>Strings are immutable. We use single quote for chars and double quote for strings. A string on a single row can be created using a single pair of double quotes, while a string on multiple rows can use a triple pair of double quotes:</p> <pre><code>a = \"a string\"\nb = \"a string\\non multiple rows\\n\"\nc = \"\"\"\n    a string\n    on multiple rows\n    \"\"\"\n</code></pre> <p>Some string operations are also present, like:</p> <ul> <li><code>split</code>: Separates string into other strings based on a char. Default char is whitespace.</li> <li><code>join([string1, string2], \"\")</code>: Concatenates strings with a certain string.</li> <li><code>replace(s, \"toSearch\" =&gt; \"toReplace\")</code>: Replaces occurrences on the string s.</li> <li><code>strip(s)</code>: Remove leading and trailing whitespaces.</li> </ul> <p>Other ways to concatenate strings:</p> <ul> <li>Concatenation operator: <code>*</code>;</li> <li>Function <code>string(string1,string2,string3)</code>;</li> <li>Interpolate string variables in a bigger one using the dollar symbol: <code>a = \"$str1 is a string and $(myobject.int1) is an integer\"</code>.</li> </ul> <p>To convert strings representing numbers to integers or floats, use <code>myInt = parse(Int64,\"2017\")</code>. To convert integers or floats to strings, use <code>myString = string(123)</code>.</p> <p>You can broadcast a function to work over a collection (instead of a scalar) using the dot (.) operator. For example, to broadcast <code>parse</code> to work over an array:</p> <pre><code>myNewList = parse.(Float64,[\"1.1\",\"1.2\"])\n</code></pre>"},{"location":"jl/#arrays","title":"Arrays","text":"<p>Arrays are N-dimensional mutable containers. Ways to create one:</p> <ul> <li><code>a = []</code> or <code>a = Int64[]</code> or <code>a = Array{T,1}()</code> or <code>a = Vector{T}()</code>: Empty array. Array{} is the constructor, T is the type and Vector{} is an alias for 1 dimensional arrays.</li> <li><code>a = zeros(5)</code> or <code>a = zeros(Int64,5)</code> or <code>a = ones(5)</code>: Array of zeros (or ones)</li> <li><code>a = fill(j, n)</code>: n-element array of identical j elements</li> <li><code>a = rand(n)</code>: n-element array of random numbers</li> <li><code>a = [1,2,3]</code>: Explicit construction (column vector).</li> <li><code>a = [1 2 3]</code>:  Row vector (this is a two-dimensional array where the first dimension is made of a single row)</li> <li><code>a = [10, \"foo\", false]</code>: Can be of mixed types, but will be much slower</li> </ul> <p>If you need to store different types on a data structure, better to use an Union: <code>a = Union{Int64,String,Bool}[10, \"Foo\", false]</code>. Some operations on arrays:</p> <ul> <li><code>a[1]</code>: Access element.</li> <li><code>a[from:step:to]</code>: Slice</li> <li><code>collect(myiterator)</code>: Transforms an iterator in an array.</li> <li><code>y = vcat(2015, 2025:2028, 2100)</code>: Initialize an array expanding the elements. 2025:2028 means [2025, 2026, 2027, 2028].</li> <li><code>push!(a,b)</code>: Append b to the end of a</li> <li><code>append!(a,b)</code>: Append the elements of b to the end of a. If b is scalar, append b to the end of a.</li> <li><code>a = [1,2,3]; b = [4,5]; c = vcat(1,a,b)</code>: Concatenation of arrays.</li> <li><code>pop!(a)</code>: Remove element from the end of a.</li> <li><code>popfirst!(a)</code>: Remove first element of a.</li> <li><code>deleteat!(a, pos)</code>: Remove element at position pos from array a.</li> <li><code>pushfirst!(a,b)</code>: Add b at the beginning of array a.</li> <li><code>sort!(a) or sort(a)</code>: Sorting, depending on whether we want to modify or not the original array.</li> <li><code>unique!(a) or unique(a)</code>: Remove duplicates</li> <li><code>a[end:-1:1]</code>: Reverses array a.</li> <li><code>in(1, a)</code>: Checks for existence.</li> <li><code>length(a)</code>: Length of array.</li> <li><code>a...</code>: The \u201csplat\u201d operator. Converts the values of an array into function parameters</li> <li><code>maximum(a) or  max(a...)</code>: Maximum value. max returns the maximum value between the given arguments.</li> <li><code>minimum(a) or  min(a...)</code>: Minimum value. min returns the minimum value between the given arguments.</li> <li><code>isempty(a)</code>: Checks if an array is empty.</li> <li><code>reverse(a)</code>: Reverses an array.</li> <li><code>sum(a)</code>: Return the summation of the elements of a.</li> <li><code>cumsum(a)</code>: Return the cumulative sum of each element of a (returns an array).</li> <li><code>empty!(a)</code>: Empty an array (works only for column vectors, not for row vectors).</li> <li><code>b = vec(a)</code>: Transform row vectors into column vectors.</li> <li><code>shuffle(a) or shuffle!(a)</code>: Random-shuffle the elements of a (requires <code>using Random</code> before).</li> <li><code>findall(x -&gt; x == value, myArray)</code>: Find a value in an array and return its indexes.</li> <li><code>enumerate(a)</code>: Get (index,element) pairs. Return an iterator to tuples, where the first element is the index of each element of the array a and the second is the element itself.</li> <li><code>zip(a,b)</code>: Get (a_element, b_element) pairs. Return an iterator to tuples made of elements from each of the arguments</li> </ul> <p>Functions that end in '!' modify their first argument.</p> <p>Map applies a function to every element in the input arrays:</p> <pre><code>map(func, my_array)\n</code></pre> <p>Filter takes a collection of values, <code>xs</code>, and returns a subset, <code>ys</code>, of those values. The specific values from <code>xs</code> that are included in the resulting <code>ys</code> are deter- mined by the predicate <code>p</code>. A predicate is a function that takes some value and always returns a Boolean value:</p> <pre><code>ys = filter(p, xs)\n</code></pre> <p>Reduce takes some binary function, <code>g</code>, as the first argument, and then uses this function to combine the elements in the collection, <code>xs</code>, provided as the second argument:</p> <pre><code>y = reduce(g, xs)\n</code></pre> <p>Mapreduce can be understood as <code>reduce(g, map(f, xs))</code>.</p>"},{"location":"jl/#multidimensional-and-nested-arrays","title":"Multidimensional and Nested Arrays","text":"<p>A matrix is an array of arrays that have the same length. The main difference between a matrix and an array of arrays is that, with a matrix, the number of elements on each column (row) must be the same and rules of linear algebra apply.</p> <p>Attention: Julia is column-major</p> <p>Ways to create one:</p> <ul> <li><code>a = Matrix{T}()</code></li> <li><code>a = Array{T}(undef, 0, 0, 0)</code></li> <li><code>a = [[1,2,3] [4,5,6]]</code>: [[elements of the first column] [elements of the second column] ...].</li> <li><code>a = hcat(col1, col2)</code>. By the columns.</li> <li><code>a = [1 4; 2 5; 3 6]</code>: [elements of the first row; elements of the second row; ...].</li> <li><code>a = vcat(row1, row2)</code>: By the rows.</li> <li><code>a = zeros(2,3)</code> or <code>a = ones(2,3)</code>: A 2x3 matrix filled with zeros or ones.</li> <li><code>a = fill(j, 2, 3)</code>: A 2x3 matrix of identical j elements</li> <li><code>a = rand(2, 3)</code>: A 2x3 matrix of random numbers</li> </ul> <p>Attention to the difference:</p> <ul> <li><code>a = [[1,2,3],[4,5,6]]</code>: creates a 1-dimensional array with 2-elements.</li> <li><code>a = [[1,2,3] [4,5,6]]</code>: creates a 2-dimensional array (a matrix with 2 columns) with three elements (scalars).</li> </ul> <p>Access the elements with <code>a[row,col]</code>. You can also make a boolean mask and apply to the matrix:</p> <pre><code>a = [[1,2,3] [4,5,6]]\nmask = [[true,true,false] [false,true,false]]\nprintln(a[mask])\n# Will print [1, 2, 5]. Always flattened.\n</code></pre> <p>Other useful operations:</p> <ul> <li><code>size(a)</code>: Returns a tuple with the sizes of the n dimensions.</li> <li><code>ndims(a)</code>: Returns the number of dimensions of the array.</li> <li><code>a'</code>: Transpose operator.</li> <li><code>reshape(a, nElementsDim1, nElementsDim2)</code>: Reshape the elements of a in a new n-dimensional array with the dimensions given.</li> <li><code>dropdims(a, dims=(dimToDrop1,dimToDrop2))</code>: Remove the specified dimensions, provided that the specified dimension has only a single element</li> </ul> <p>These last three operations performe only a shallow copy (a view) on the matrix, so if the underlying matrix changes, the view also changes. Use <code>collect(reshape/dropdims/transpose)</code> to force a deep copy.</p>"},{"location":"jl/#tuples","title":"Tuples","text":"<p>Tuples are an immutable collection of elements. Initialize with <code>a = (1,2,3)</code> or <code>a = 1,2,3</code>. Tuples can be unpacked like so: <code>var1, var2 = (x,y)</code>. And you can convert a tuple into a vector like this: <code>v = collect(a)</code>.</p>"},{"location":"jl/#named-tuples","title":"Named Tuples","text":"<p>Named tuples are immutable collections of items whose position in the collection (index) can be identified not only by their position but also by their name.</p> <ul> <li><code>nt = (a=1, b=2.5)</code>: Define a NamedTuple</li> <li><code>nt.a</code>: Access the elements with the dot notation</li> <li><code>keys(nt)</code>: Return a tuple of the keys</li> <li><code>values(nt)</code>: Return a tuple of the values</li> <li><code>collect(nt)</code>: Return an array of the values</li> <li><code>pairs(nt)</code>: Return an iterable of the pairs (key,value). Useful for looping: <code>for (k,v) in pairs(nt) [...] end</code></li> </ul>"},{"location":"jl/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries are mutable mappings from keys to values. Ways to create one:</p> <ul> <li><code>mydict = Dict{T,U}()</code></li> <li><code>mydict = Dict('a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3)</code></li> </ul> <p>Useful operations:</p> <ul> <li><code>mydict[key] = value</code>: Add pairs to the dictionary</li> <li><code>mydict[key]</code>: Look up value. If it doesn't exist, raises error.</li> <li><code>get(mydict,'a',0)</code>: Look up value with a default value for non-existing key.</li> <li><code>keys(mydict)</code>: Get all keys. Results in an iterator. Use collect() to transform into array.</li> <li><code>values(mydict)</code>: Iterator of all the values.</li> <li><code>haskey(mydict, 'a')</code>: Checks if a key exists.</li> <li><code>in(('a' =&gt; 1), mydict)</code>: Checks if a given key/value pair exists.</li> <li><code>delete!(amydict,'akey')</code>: Delete the pair with the specified key from the dictionary.</li> </ul> <p>You can iterate over both keys and values:</p> <pre><code>for (k,v) in mydict\n   println(\"$k is $v\")\nend\n</code></pre>"},{"location":"jl/#sets","title":"Sets","text":"<p>A set is a mutable collection of unordered and unique values. Ways to create one:</p> <ul> <li><code>a = Set{T}()</code>: Empty set</li> <li><code>a = Set([1,2,2,3,4])</code>: Initialize with values</li> <li><code>push!(s, 5)</code>: Add elements</li> <li><code>delete!(s,1)</code>: Delete elements</li> <li><code>intersect(set1,set2)</code>, <code>union(set1,set2)</code>, <code>setdiff(set1,set2)</code>: Intersection, union, and difference.</li> </ul>"},{"location":"jl/#memory-and-copy","title":"Memory and Copy","text":"<p>Shallow copy (copy of the memory address only) is the default in Julia. Some observations:</p> <ul> <li><code>a = b</code>: This is a name binding. It binds the entity referenced by <code>b</code> to the <code>a</code> identifier. If <code>b</code> rebinds to some other object, <code>a</code> remains referenced to the original object. If the object referenced by <code>b</code> mutates, so does those referenced by <code>a</code>.</li> <li>When a variable receives other variable: Basic types (Float64, Int64, String) are deep copied. Containers are shallow copied.</li> <li><code>copy(x)</code>: Simple types are deep copied, containers of simple types are deep copied, containers of containers, the content is shadow copied (the content of the content is only referenced, not copied).</li> <li><code>deepcopy(x)</code>: Everything is deep copied recursively.</li> </ul> <p>Observations on types:</p> <p>You can check if two objects have the same values with <code>==</code> and if two objects are actually the same with <code>===</code>.</p> <p>To cast an object into a different type:</p> <pre><code>convertedObj = convert(T,x)\n</code></pre>"},{"location":"jl/#random-numbers","title":"Random Numbers","text":"<ul> <li><code>rand()</code>: Random float in [0,1].</li> <li><code>rand(a:b)</code>: Random integer in [a,b].</li> <li><code>rand(a:0.01:b)</code>: Random float in [a,b] with \"precision\" to the second digit.</li> <li><code>rand(2,3)</code>: Random 2x3 matrix.</li> <li><code>rand(DistributionName([distribution parameters]))</code>: Random float in [a,b] using a particular distribution (Normal, Poisson,...). Requires the Distributions package.</li> <li><code>rand(Uniform(a,b))</code>: Random float in [a,b] using an uniform distribution.</li> <li><code>import Random:seed!; seed!(1234)</code>: Sets a seed.</li> </ul>"},{"location":"jl/#basic-syntax","title":"Basic Syntax","text":"<p>The typical control flow is present:</p> <pre><code># 1 and 5 are included on this range\nfor i = 1:5\n    println(i)\nend\n\nfor j in [1, 2, 3]\n    println(j)\nend\n\n# Nested loops:\nfor i = 1:2, j = 3:4\n    println((i, j))\nend\n\ni = 0\nwhile i &lt; 5\n    println(i)\n    global i += 1\nend\n\nif x &lt; y\n    println(\"x is less than y\")\nelseif x &gt; y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n</code></pre> <p>There are list comprehensions:</p> <pre><code>[myfunction(i) for i in [1,2,3]]\n\n[x + 2y for x in [10,20,30], y in [1,2,3]]\n\nmydict = Dict()\n[mydict[i]=value for (i, value) in enumerate(mylist)]\n# enumerate returns an iterator to tuples with the index and the value of elements in an array\n\n[students[name] = sex for (name,sex) in zip(names,sexes)]\n# zip returns an iterator of tuples pairing two or multiple lists, e.g. [(\"Marc\",\"M\"),(\"Anne\",\"F\")]\n\nmap((n,s) -&gt; students[n] = s, names, sexes)\n# map applies a function to a list of arguments\n</code></pre> <p>The ternary operator is present:</p> <pre><code>a ? b : c\n# If a is true, then b, else c\n</code></pre> <p>The usual logic operators exist:</p> <ul> <li>And: <code>&amp;&amp;</code></li> <li>Or:  <code>||</code></li> <li>Not: <code>!</code></li> </ul>"},{"location":"jl/#functions","title":"Functions","text":"<p>Functions can be declared like so:</p> <pre><code>function f(x)\n    x+2\nend\n</code></pre> <p>Function arguments are normally specified by position (positional arguments). However, if a semicolon (;) is used in the parameter list of the function definition, the arguments listed after that semicolon must be specified by name (keyword arguments).</p> <pre><code>function func(a,b=1;c=2)\n    # blabla\nend\n\n# Optionally restrict the types of argument the function should accept by annotating the parameter with the type:\nfunction func(a::Int64,b::Int64=1;c::Int64=2)\n    # blabla\nend\n</code></pre> <p>Function that can operate on some types but not others:</p> <pre><code># This function can operate on Float64 or on a Vector of Float64.\nfunction func(par::Union{Float64, Vector{Float64}})\n    # In the body we check the type using typeof()\nend\n</code></pre> <p>Function with variable number of arguments:</p> <pre><code># The splat operator (...) can specify a variable number of arguments in the parameter declaration\nfunction func(a, args...)\n    # The parameter that uses the ellipsis must be the last one\n    # In the body we use args as an iterator\nend\n</code></pre> <p>Julia has multiple-dispatch. If you declare the same function with different arguments, the compiler will choose the correct function to call based on the arguments you passed. You can also do type parametrization on functions:</p> <pre><code>function f(x::T)\n    x+2\nend\n\nmyfunction(x::T, y::T2, z::T2) where {T &lt;: Number, T2} = 5x + 5y + 5z\n</code></pre> <p>Functions are objects that can be assigned to new variables, returned, or nested:</p> <pre><code>f(x) = 2x   # define a function f inline\na = f(2)    # call f and assign the return value to a\na = f       # bind f to a new variable name (it's not a deep copy)\na(5)        # call again the (same) function\n</code></pre> <p>Functions work on new local variables, known only inside the function itself. Assigning the variable to another object will not influence the original variable. But if the object bound with the variable is mutable (e.g., an array), the mutation of this object will apply to the original variable as well:</p> <pre><code>function f(x,y)\n    x = 10\n    y[1] = 10\nend\n\nx = 1\ny = [1,1]\n\n# x will not change, but y will now be [10,1]\nf(x,y)\n</code></pre> <p>Functions that change their arguments have their name, by convention, followed by an '!'. The first parameter is, still by convention, the one that will be modified.</p> <p>Anonymous functions can be declared like so:</p> <pre><code>(x, y) -&gt; x^2 + 2y - 1\n# you can assign an anonymous function to a variable.\n</code></pre> <p>You can broadcast a function to work over all the elements of an array:</p> <pre><code>myArray = broadcast(i -&gt; replace(i, \"x\" =&gt; \"y\"), myArray)\n\n# Or like this:\nf = i -&gt; replace(i, \"x\" =&gt; \"y\")\nmyArray = f.(myArray)\n</code></pre> <p>Functions whose name is a singular symbol can be used on an infix or prefix form:</p> <pre><code>5 + 3\n\n+(5, 3)\n</code></pre>"},{"location":"jl/#custom-types","title":"Custom Types","text":"<p>There are two type operators:</p> <ul> <li>The <code>::</code> operator is used to constrain an object of being of a given type. For example, <code>a::B</code> means \u201ca must be of type B\u201d.</li> <li>The <code>&lt;:</code> operator has a similar meaning, but it\u2019s a bit more relaxed in the sense that the object can be of any subtypes of the given type. For example, <code>A&lt;:B</code> means \u201cA must be a subtype of B\u201d, that is, B is the \u201cparent\u201d type and A is its \u201cchild\u201d type.</li> </ul> <p>You can define structures like this:</p> <pre><code># Structs are immutable by default. Hence the mutable keyword.\n# Immutable structs are much faster.\nmutable struct MyStruct\n  property1::Int64\n  property2::String\nend\n\n# Parametrized:\nmutable struct MyStruct2{T&lt;:Number}\n property1::Int64\n property2::String\n property3::T\nend\n\n# Instantiating and accessing attribute:\nmyObject = MyStruct(20,\"something\")\na = myObject.property1 # 20\n</code></pre> <p>Attention to this:</p> <ul> <li><code>a::B</code>: Means \"a must be of type B\".</li> <li><code>A&lt;:B</code>: Means \"A must be a subtype of B\".</li> </ul> <p>An example of object orientation in Julia:</p> <pre><code>struct Person\n  myname::String\n  age::Int64\nend\n\nstruct Shoes\n    shoesType::String\n    colour::String\nend\n\nstruct Student\n    s::Person\n    school::String\n    shoes::Shoes\nend\n\nfunction printMyActivity(self::Student)\n    println(\"I study at $(self.school) school\")\nend\n\nstruct Employee\n    s::Person\n    monthlyIncomes::Float64\n    company::String\n    shoes::Shoes\nend\n\nfunction printMyActivity(self::Employee)\n    println(\"I work at $(self.company) company\")\nend\n\ngymShoes = Shoes(\"gym\",\"white\")\nproShoes = Shoes(\"classical\",\"brown\")\n\nMarc = Student(Person(\"Marc\",15),\"Divine School\",gymShoes)\nMrBrown = Employee(Person(\"Brown\",45),1200.0,\"ABC Corporation Inc.\", proShoes)\n\nprintMyActivity(Marc)\nprintMyActivity(MrBrown)\n</code></pre> <p>Observations:</p> <ul> <li>Functions are not associated to a type. Do not call a function over a method (<code>myobj.func(x,y)</code>) but rather you pass the object as a parameter (<code>func(myobj, x, y)</code>)</li> <li>Julia doesn't use inheritance, but rather composition (a field of the subtype is of the higher type, allowing access to its fields).</li> </ul> <p>Some useful functions:</p> <ul> <li><code>supertype(MyType)</code>: Returns the parent types of a type.</li> <li><code>subtypes(MyType)</code>: Lists all children of a type.</li> <li><code>fieldnames(MyType)</code>: Queries all the fields of a structure.</li> <li><code>isa(obj,MyType)</code>: Checks if obj is of type MyType.</li> <li><code>typeof(obj)</code>: Returns the type of obj.</li> </ul>"},{"location":"jl/#io","title":"I/O","text":"<p>Opening a file is similar to Python. The file closes automatically in the end:</p> <pre><code># Write to file\nopen(\"file.txt\", \"w\") do f  # \"w\" for writing, \"r\" for read and \"a\" for append.\n    write(f, \"test\\n\")      # \\n for newline\nend\n\n# Read whole file:\nopen(\"file.txt\", \"r\") do f\n  filecontent = read(f,String)\n  print(filecontent)\nend\n\n# Read line by line:\nopen(\"file.txt\", \"r\") do f\n    for ln in eachline(f)\n        println(ln)\n    end\nend\n\n# Read, keeping track of line numbers:\nopen(\"file.txt\", \"r\") do f\n    for (i,ln) in enumerate(eachline(f))\n        println(\"$i $ln\")\n    end\nend\n</code></pre>"},{"location":"jl/#metaprogramming","title":"Metaprogramming","text":"<p>TODO</p>"},{"location":"jl/#exceptions","title":"Exceptions","text":"<p>Exceptions are similar to Python:</p> <pre><code>try\n    # Some dangerous code...\ncatch\n    # What to do if an error happens, most likely send an error message using:\n    error(\"My detailed message\")\nend\n\n# Check for specific exception:\nfunction volume(region, year)\n    try\n        return data[\"volume\",region,year]\n    catch e\n        if isa(e, KeyError)\n            return missing\n        end\n        rethrow(e)\n    end\nend\n</code></pre>"},{"location":"jl/#repl","title":"REPL","text":"<p>One can load a Julia file into the REPL to experiment with it:</p> <pre><code>include(\"my_file.jl\")\n</code></pre>"},{"location":"jl/#dataframes","title":"DataFrames","text":"<p>Examples:</p> <pre><code># Read data from a CSV\nusing DataFrames, CSV\nmyData = CSV.read(file, DataFrame, header = 1, copycols = true, types=Dict(:column_name =&gt; Int64))\n\n# Read data from the web:\nusing DataFrames, HTTP, CSV\nresp = HTTP.request(\"GET\", \"https://data.cityofnewyork.us/api/views/kku6-nxdu/rows.csv?accessType=DOWNLOAD\")\ndf = CSV.read(IOBuffer(String(resp.body)))\n\n# Read data from spreadsheet:\nusing DataFrames, OdsIO\ndf = ods_read(\"spreadsheet.ods\";sheetName=\"Sheet2\",retType=\"DataFrame\",range=((tl_row,tl_col),(br_row,br_col)))\n\n# Empty df:\ndf = DataFrame(A = Int64[], B = Float64[])\n</code></pre> <p>Insights about the data:</p> <ul> <li><code>first(df, 6)</code></li> <li><code>show(df, allrows=true, allcols=true)</code></li> <li><code>last(df, 6)</code></li> <li><code>describe(df)</code></li> <li><code>unique(df.fieldName)</code> or <code>[unique(c) for c in eachcol(df)]</code></li> <li><code>names(df)</code>: Returns array of column names</li> <li><code>[eltype(col) for col = eachcol(df)]</code>: Returns an array of column types</li> <li><code>size(df)</code>: (r,c); <code>size(df)[1]</code>: (r); <code>size(df)[2]</code>: (c).</li> <li><code>ENV[\"LINES\"] = 60</code>: Change the default number of lines before the content is - truncated (default 30).</li> <li><code>for c in eachcol(df)</code>: Iterates over each column.</li> <li><code>for r in eachrow(df)</code>: iterates over each row.</li> </ul> <p>To query the data from a DataFrame you can use the Query package. Examples:</p> <pre><code>using Query\n\ndfOut = @from i in df begin\n           @where i.col1 &gt; 1\n           @select {aNewColName=i.col1, i.col3}\n           @collect DataFrame\n        end\n dfOut = @from i in df begin\n            @where i.value != 1 &amp;&amp; i.cat1 in [\"green\",\"pink\"]\n            @select i\n            @collect DataFrame\n        end\n</code></pre>"},{"location":"jl/#performance","title":"Performance","text":"<p>Statically typing the program, or facilitating the type inference of the JIT compiler makes the code run faster. Some notes:</p> <ul> <li>Avoid global variables and run your performance-critical code within functions rather than in the global scope;</li> <li>Annotate the inner type of a container, so it can be stored in memory contiguously;</li> <li>Annotate the fields of composite types (use eventually parametric types);</li> <li>Loop matrices first by column and then by row.</li> </ul> <p>Notes on profiling :</p> <ul> <li>To time a part of the code type <code>@time myFunc(args)</code> (be sure you ran that function at least once, or you will measure compile time rather than run-time).</li> <li><code>@benchmark myFunc(args)</code> (from package BenchmarkTools) also works.</li> <li>Profile a function: <code>Profile.@profile myfunct()</code> (best after the function has been already ran once for JIT-compilation).</li> <li>Print the profiling results: <code>Profile.print()</code> (number of samples in corresponding line and all downstream code; file name:line number; function name;)</li> <li>Explore a chart of the call graph with profiled data: <code>ProfileView.view()</code> (from package ProfileView).</li> <li>Clear profile data: <code>Profile.clear()</code>.</li> </ul>"},{"location":"jl/#plotting","title":"Plotting","text":"<p>The Plots package provides an unified API to several supported backends. Install the packages \"Plots\" and at least one backend, like <code>PlotlyJS</code> or <code>PyPlot.jl</code>. Example:</p> <pre><code>using Plots\nplotlyjs()\nplot(sin, -2pi, pi, label=\"sine function\")\n</code></pre>"},{"location":"jl/#references","title":"References","text":"<ul> <li>Julia language: a concise tutorial.</li> <li>Julia Language Manual.</li> <li>Antonello Lobianco. Julia Quick Syntax Reference. 1st Edition. Apress.</li> <li>Erik Engheim. Julia as a Second Language. 1st Edition. Manning.</li> </ul>"},{"location":"one/","title":"Notes on OpenNebula","text":""},{"location":"one/#typical-architecture","title":"Typical Architecture","text":""},{"location":"one/#sunstone","title":"Sunstone","text":"<ul> <li>Is the graphical user interface of OpenNebula;</li> <li>Responsible for serving the Web GUI, oned service, perform environment monitoring as well as management of network, storage or VMs</li> <li>Listens on 2616/tcp;</li> <li>Same website for admins and users, but has different views based on permissions;</li> <li>Each user can set SSH keys, 2FA and labels on his account;</li> <li>Labels can be used to categorize resources.</li> <li>Inspect <code>/var/log/one/oned.log</code> and <code>/var/log/one/monitor.log</code> log files in case there is an error in the frontend.</li> </ul>"},{"location":"one/#configuration","title":"Configuration","text":"<ul> <li>To make sure the state of the cloud is persistent, OpenNebula will keep it stored in a SQL database;</li> <li>The options are SQLite (automatic), MariaDB and MySQL;</li> <li>This is configured on <code>/etc/one/oned.conf</code> at the host;</li> <li>During the installation of the software the system user <code>oneadmin</code> will be created. Services and CLI tools are going to be used by this user;</li> <li>During the first launch OpenNebula is going to create a Sunstone admin user for the deployment. Credentials are stored in a dedicated file <code>.one/one_auth</code>;</li> <li>We must configure hosts that are going to run the VMs before adding them to a OpenNebula cluster and provide them with monitoring and virtualization drivers;</li> <li>To configure the host we must add the OpenNebula repo, install <code>opennebula-node-kvm</code> and configure passwordless ssh connection from the Sunstone node to the host and vice versa;</li> <li>Then on the Sunstone section <code>Infrastructure/Hosts</code>, add a KVM host by putting its IP;</li> <li>Through the CLI:</li> </ul> <pre><code>sudo -i -u oneadmin\n\nonehost create 'node2.dev.corp' -i kvm -v kvm\n\nonehost show 1\n</code></pre>"},{"location":"one/#cli","title":"CLI","text":"<ul> <li><code>oneuser</code>: Manage Users</li> <li><code>oneimage</code>: Manage Images</li> <li><code>onegroup</code>: Manage Groups</li> <li><code>onetemplate</code>: Manage Templates</li> <li><code>oneacl</code>: Manage ACLs</li> <li><code>oneacct</code>: Accounting Tool</li> <li><code>onehost</code>: Manage Hosts</li> <li><code>onemarket</code>: Marketplace Tool</li> <li><code>onecluster</code>: Manage Clusters</li> <li><code>onedb</code>: DB Tool</li> <li><code>onevnet</code>: Manage Networks</li> <li><code>oneflow</code>: Manage flows (services)</li> <li><code>onedatastore</code>: Manage Datastores</li> <li><code>onemarketapp</code>: Import marketapps</li> <li><code>oneshowback</code>: Showback</li> <li><code>onevrouter</code>: Manage virtual routers</li> <li><code>onevdc</code>: Manage VDCs</li> <li><code>onesecgroup</code>: Manage sec. groups</li> <li><code>onevcenter</code>: Import vCenter resources</li> <li><code>oneprovision</code>: Manage provisions</li> <li><code>onecfg</code>: Manage configuration files</li> <li><code>oneprovider</code>: Manage providers</li> <li><code>onezone</code>: Manage zones onehook Manage hooks</li> </ul> <p>Flags to output in a machine-readable format:</p> <ul> <li><code>-j</code> for JSON</li> <li><code>-x</code> for XML</li> <li><code>-y</code> for YAML</li> </ul>"},{"location":"one/#virtual-networks","title":"Virtual Networks","text":"<ul> <li>Can be created under the Networks section of Sunstone;</li> <li>Can be a <code>Bridge</code>, <code>Open vSwitch</code>, <code>VXLAN</code>, etc;</li> <li>On the <code>Addresses</code> tab, we can set the IP range of that network;</li> <li>On the <code>Context</code> tab, we can set gateway, DNS and IP assignment method (DHCP or static);</li> <li>On the <code>Virtual Network</code> subsection, we can make a reservation on a certain network, meaning a portion of the network is going to be locked and available only to specific resources. The network is partitioned by IP address;</li> <li>On the <code>Lease</code> tab, we can also hold a specific IP address on a virtual network, so it cannot be used nor reserved;</li> <li>The <code>Network Templates</code> section can be used to speed the creation of new virtual networks;</li> <li>We can use the CLI as such: <code>onevnet create &lt;path/to/file&gt;</code> where file is a textfile containing parameters;</li> </ul>"},{"location":"one/#marketplace","title":"Marketplace","text":"<ul> <li>Is the repository of pre-build images, VM templates and service templates;</li> <li>Can be public or private;</li> <li>The public marketplace contains ready-to-use images;</li> <li>These images are based on the vanilla ISOs, but with virtualization packages;</li> <li>The different marketplaces configured are found under the <code>Storage</code> section, <code>Marketplaces</code> subsection;</li> <li>The <code>Apps</code> subsection contains all images available to the user;</li> </ul>"},{"location":"one/#storage","title":"Storage","text":"<ul> <li>We don't create a VM based on an image, but rather on a template. The template points to an image;</li> <li>Multiple VM templates can use the same image;</li> <li>The <code>Images</code> subsection contains the downloaded images ready to be used, as well as system snapshots, which are considered an image;</li> <li>A <code>datastore</code> is the location where files are saved. It can be:</li> <li><code>Images Datastore</code>, which stores the base operating system images, persistent data volumes, CD-ROMs.</li> <li><code>System Datastore</code> holds disks of running Virtual Machines. Disk are moved from/to the Images when the VMs are deployed/terminated.</li> <li><code>Files &amp; Kernels Datastore</code> to store plain files (not disk images), e.g. kernels, ramdisks, or contextualization files.</li> <li>Create a new datastore at <code>Storage/Datastores</code> on Sunstone;</li> <li>Or use the CLI <code>onedatastore create &lt;path/to/file&gt;</code> where file is a textfile containing parameters;</li> <li><code>Services</code> are images that contain an app (such as Wordpress) along with an OS. They are also stored on a datastore.</li> </ul>"},{"location":"one/#virtual-machines","title":"Virtual Machines","text":"<ul> <li>Currently instantiated VMs can be found at <code>Instances/VMs</code> on Sunstone or queried through the CLI with <code>onevm</code>;</li> <li><code>VM Templates</code> are a textual representation of a VM;</li> <li>It contains pointers to images, parameters and other configurations;</li> <li>Some of those can be adjusted only by the administrator;</li> <li>Services also rely on VM Templates;</li> <li>VM Templates can be edited on the <code>Templates</code> section or queried through the CLI with <code>onetemplate</code>;</li> <li>VMs can be deployed alone or in batches;</li> <li>VMs can be accessed from Sunstone via VNC;</li> <li>VMs can be backed up or turned into an Image;</li> <li>We can make a snapshot of the VM's disk or of the entire VM;</li> <li>Restoring a disk snapshot is only possible with the VM powered down;</li> <li>Restoring a VM snapshot is possible at any time;</li> <li>VM configuration can be changed while it is running. It'll go into a hotplug state to apply the changes;</li> <li>VMs can be deployed through the CLI <code>onevm create --cpu 1 --memory 1024 --disk 2 --nic 5</code>;</li> </ul>"},{"location":"one/#users-groups-and-permissions","title":"Users, Groups and Permissions","text":"<ul> <li>Permissions exists for <code>owners</code>, <code>groups</code> and <code>others</code>;</li> <li>The levels are <code>use</code>, <code>manage</code> and <code>admin</code>;</li> <li><code>Use</code> is for operations that do not modify the resource, <code>manage</code> for the ones that modify and <code>admin</code> for high responsability modifications;</li> <li>Each user is going to be attached to at least one group;</li> <li>Each group may have a separate group administrator. Group administrators are delegated with permissions to manage groups resources and add new users;</li> <li>By default, OpenNebula has two groups - <code>oneadmin</code> and <code>users</code>;</li> <li>By default, OpenNebula also going to have two users - oneadmin (if one_auth wasn't altered) and serveradmin(service user used for internal purposes);</li> <li>Groups can be created at <code>System/Groups</code>on Sunstone or through the CLI <code>onegroup create --name ops --admin_user ops-admin --admin_password 'Pa$$w0rd'</code>;</li> <li>can be created at <code>System/Users</code>on Sunstone or through the CLI <code>oneuser create basic_user 'Pa$$w0rd' --group 102</code>;</li> </ul>"},{"location":"py/","title":"Notes on Python","text":""},{"location":"py/#general-project-guidance","title":"General Project Guidance","text":""},{"location":"py/#project-layout","title":"Project Layout","text":"<p>Avoid storing unit tests outside the package directory. These tests should be included in a subpackage of your software so that they aren\u2019t automatically installed as a <code>tests</code> top-level module by setuptools (or some  other packaging library) by accident. By placing them in a subpackage, you ensure they can be installed and eventually used by other packages so users can build their own unit tests.</p> <p>Note that using <code>setup.py</code> is highly unadvised as it introduces arbitrary code into the build process. Also, executing the <code>setup.py</code> directly is deprecated.</p> <p>Some optional folders can also appear:</p> <ul> <li><code>etc</code> for sample configuration files</li> <li><code>tools</code> for shell scripts or related tools</li> <li><code>bin</code> for binary scripts you\u2019ve written that will be installed by setup.py</li> </ul> <p>Organize the code based on features, not on file types. Don't create <code>functions.py</code> or <code>exceptions.py</code> files, but rather <code>api.py</code> or <code>time_travel.py</code> files.</p> <p>Don't create a module folder which only contains an <code>__init__.py</code> file. If you create a module folder, it should contain several files that belong to it's category.</p> <p>Be careful about the code that you put in the <code>__init__.py</code> file. This file will be called and executed the first time that a module contained in the directory is loaded. Placing the wrong things in your <code>__init__.py</code> can have unwanted side effects. In fact, <code>__init__.py</code> files should be empty most of the time. Don\u2019t try to remove <code>__init__.py</code> files altogether though, or you won\u2019t be able to import your Python module at all: Python requires an <code>__init__.py</code> file to be present for the directory to be considered a submodule.</p>"},{"location":"py/#versioning","title":"Versioning","text":"<p>Two main ways to version Python software:</p>"},{"location":"py/#pep-440-pypa-guidelines","title":"PEP 440 / PyPA Guidelines","text":"<p>It must obey the following regex: <code>N[.N]+[{a|b|c|rc}N][.postN][.devN]</code></p> <p>This means versions such as <code>1.2.0</code> and <code>0.4.7</code> are allowed. Also:</p> <ul> <li>Version <code>1.3.0</code> is quivalent to <code>1.3</code></li> <li>Versions matching <code>N[.N]+</code> (no suffix) are considered final releases.</li> <li><code>N[.N]+aN</code> (e.g., <code>1.2a1</code>) denotes an alpha release, i.e., a version that might be unstable and missing features.</li> <li><code>N[.N]+bN</code> (e.g., <code>1.2b1</code>) denotes a beta release, i.e., a version that might be feature complete but still buggy.</li> <li><code>N[.N]+rcN</code> (e.g., <code>0.4rc1</code>) denotes a release candidate, i.e., a version that might be released as the final product unless significant bugs emerge.</li> <li>The suffix <code>.postN</code> (e.g., <code>1.4.post2</code>) indicates a post release. Post releases are typically used to address minor errors in the publication process, such as mistakes in release notes. You shouldn\u2019t use the .postN suffix when releasing a bug-fix version, instead, increment the minor version number.</li> <li>The suffix <code>.devN</code> (e.g., <code>2.3.4.dev3</code>) indicates a developmental release. It indicates a prerelease of the version that it qualifies: e.g., 2.3.4.dev3 indicates the third developmental version of the 2.3.4 release, prior to any alpha, beta, candidate, or final release. This suffix is discouraged because it is harder for humans to parse.</li> </ul> <p>More details here.</p>"},{"location":"py/#semantic-versioning","title":"Semantic Versioning","text":"<p>Given a version number <code>MAJOR.MINOR.PATCH</code> (<code>X.Y.Z</code>), increment the:</p> <ul> <li><code>MAJOR</code> version when you make incompatible API changes</li> <li><code>MINOR</code> version when you add functionality in a backward compatible manner</li> <li><code>PATCH</code> version when you make backward compatible bug fixes</li> </ul> <p>Software using Semantic Versioning MUST declare a public API. This API could be declared in the code itself or exist strictly in documentation. However it is done, it SHOULD be precise and comprehensive.</p> <p>A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes. X is the major version, Y is the minor version, and Z is the patch version. Each element MUST increase numerically. For instance: <code>1.9.0</code> -&gt; <code>1.10.0</code> -&gt; <code>1.11.0</code>.</p> <p>Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.</p> <p>Major version zero (<code>0.y.z</code>) is for initial development. Anything MAY change at any time. The public API SHOULD NOT be considered stable.</p> <p>Version 1.0.0 defines the public API. The way in which the version number is incremented after this release is dependent on this public API and how it changes.</p> <p>Patch version Z (<code>x.y.Z</code> | x &gt; 0) MUST be incremented if only backward compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.</p> <p>Minor version Y (<code>x.Y.z</code> | x &gt; 0) MUST be incremented if new, backward compatible functionality is introduced to the public API. It MUST be incremented if any public API functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented.</p> <p>Major version X (<code>X.y.z</code> | X &gt; 0) MUST be incremented if any backward incompatible changes are introduced to the public API. It MAY also include minor and patch level changes. Patch and minor versions MUST be reset to 0 when major version is incremented.</p> <p>A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphens <code>[0-9A-Za-z-]</code>. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: <code>1.0.0-alpha</code>, <code>1.0.0-alpha.1</code>, <code>1.0.0-0.3.7</code>, <code>1.0.0-x.7.z.92</code>, <code>1.0.0-x-y-z.--.</code></p> <p>Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphens <code>[0-9A-Za-z-]</code>. Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: <code>1.0.0-alpha+001</code>, <code>1.0.0+20130313144700</code>, <code>1.0.0-beta+exp.sha.5114f85</code>, <code>1.0.0+21AF26D3----117B344092BD</code>.</p> <p>More details here.</p>"},{"location":"py/#linting-and-formating","title":"Linting and Formating","text":"<p>Use PEP8 to ensure good style of your code:</p> <ul> <li>Use four spaces per indentation level.</li> <li>Limit all lines to a maximum of 79 characters (this is debatable).</li> <li>Separate top-level function and class definitions with two blank lines.</li> <li>Encode files using ASCII or UTF-8.</li> <li>Use one module import per import statement and per line. Place import statements at the top of the file, after comments and docstrings, grouped first by standard, then by third party, and finally by local library imports.</li> <li>Do not use extraneous whitespaces between parentheses, square brackets, or braces or before commas.</li> <li>Write class names in camel case (e.g., <code>CamelCase</code>), suffix exceptions with <code>Error</code> (if applicable), name functions in lowercase with words and underscores (e.g., <code>my_function</code>) and use a leading underscore for <code>_private</code> attributes or methods.</li> </ul> <p>One should run linters, type checkers and formaters directly from the code editor and on CI/CD pipelines.</p>"},{"location":"py/#ruff","title":"Ruff","text":"<p>Ruff is an extremely fast Python linter and formatter, written in Rust. Ruff can be used to replace Black, Flake8 (plus dozens of plugins), isort, pydocstyle, pyupgrade, and more. It can be used on VSCode or on a pipeline.</p> <p>Usage as a linter:</p> <pre><code>ruff check .                        # Lint all files in the current directory (and any subdirectories).\nruff check path/to/code/            # Lint all files in `/path/to/code` (and any subdirectories).\nruff check path/to/code/*.py        # Lint all `.py` files in `/path/to/code`.\nruff check path/to/code/to/file.py  # Lint `file.py`.\nruff check @arguments.txt           # Lint using an input file, treating its contents as newline-delimited command-line arguments.\n</code></pre> <p>Usage as a formatter:</p> <pre><code>ruff format .                        # Format all files in the current directory (and any subdirectories).\nruff format path/to/code/            # Format all files in `/path/to/code` (and any subdirectories).\nruff format path/to/code/*.py        # Format all `.py` files in `/path/to/code`.\nruff format path/to/code/to/file.py  # Format `file.py`.\nruff format @arguments.txt           # Format using an input file, treating its contents as newline-delimited command-line arguments.\n</code></pre> <p>Usage as a Github Action:</p> <pre><code>name: Ruff\non: [ push, pull_request ]\njobs:\n  ruff:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: chartboost/ruff-action@v1\n</code></pre>"},{"location":"py/#configuration","title":"Configuration","text":"<p>Ruff can be configured through a <code>pyproject.toml</code>, <code>ruff.toml</code>, or <code>.ruff.toml</code> file (see: Configuration, or Settings for a complete list of all configuration options).</p> <p>If left unspecified, Ruff's default configuration is equivalent to:</p> <pre><code>[tool.ruff]\n# Exclude a variety of commonly ignored directories.\nexclude = [\n    \".bzr\",\n    \".direnv\",\n    \".eggs\",\n    \".git\",\n    \".git-rewrite\",\n    \".hg\",\n    \".ipynb_checkpoints\",\n    \".mypy_cache\",\n    \".nox\",\n    \".pants.d\",\n    \".pyenv\",\n    \".pytest_cache\",\n    \".pytype\",\n    \".ruff_cache\",\n    \".svn\",\n    \".tox\",\n    \".venv\",\n    \".vscode\",\n    \"__pypackages__\",\n    \"_build\",\n    \"buck-out\",\n    \"build\",\n    \"dist\",\n    \"node_modules\",\n    \"site-packages\",\n    \"venv\",\n]\n\n# Same as Black.\nline-length = 88\nindent-width = 4\n\n# Assume Python 3.8\ntarget-version = \"py38\"\n\n[tool.ruff.lint]\n# Enable Pyflakes (`F`) and a subset of the pycodestyle (`E`)  codes by default.\nselect = [\"E4\", \"E7\", \"E9\", \"F\"]\nignore = []\n\n# Allow fix for all enabled rules (when `--fix`) is provided.\nfixable = [\"ALL\"]\nunfixable = []\n\n# Allow unused variables when underscore-prefixed.\ndummy-variable-rgx = \"^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$\"\n\n[tool.ruff.format]\n# Like Black, use double quotes for strings.\nquote-style = \"double\"\n\n# Like Black, indent with spaces, rather than tabs.\nindent-style = \"space\"\n\n# Like Black, respect magic trailing commas.\nskip-magic-trailing-comma = false\n\n# Like Black, automatically detect the appropriate line ending.\nline-ending = \"auto\"\n</code></pre> <p>Some configuration options can be provided via the command-line, such as those related to rule enablement and disablement, file discovery, and logging level:</p> <pre><code>ruff check path/to/code/ --select F401 --select F403 --quiet\n</code></pre> <p>See <code>ruff help</code> for more on Ruff's top-level commands, or <code>ruff help check</code> and <code>ruff help format</code> for more on the linting and formatting commands, respectively.</p> <p>Ruff supports over 700 lint rules, many of which are inspired by popular tools like Flake8, isort, pyupgrade, and others. Regardless of the rule's origin, Ruff re-implements every rule in Rust as a first-party feature.</p> <p>By default, Ruff enables Flake8's <code>F</code> rules, along with a subset of the <code>E</code> rules, omitting any stylistic rules that overlap with the use of a formatter, like <code>ruff format</code> or Black.</p> <p>If you're just getting started with Ruff, the default rule set is a great place to start: it catches a wide variety of common errors (like unused imports) with zero configuration.</p> <p>For a complete enumeration of the supported rules, see Rules.</p>"},{"location":"py/#pyright","title":"PyRight","text":"<p>My choice on static checking for Python. More information here.</p>"},{"location":"py/#modules-libraries-and-frameworks","title":"Modules, Libraries and Frameworks","text":""},{"location":"py/#importing","title":"Importing","text":"<p>The import keyword is actually a wrapper around a function named <code>__import__</code>.</p> <pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; itertools\n# &lt;module 'itertools' from '/usr/.../&gt;\n</code></pre> <p>is equivalent to</p> <pre><code>&gt;&gt;&gt; itertools = __import__(\"itertools\")\n&gt;&gt;&gt; itertools\n# &lt;module 'itertools' from '/usr/.../&gt;\n</code></pre> <p>also, it's possible to</p> <pre><code>&gt;&gt;&gt; it = __import__(\"itertools\")\n&gt;&gt;&gt; it\n# &lt;module 'itertools' from '/usr/.../&gt;\n</code></pre> <p>Modules, once imported, are essentially objects whose attributes are objects.</p>"},{"location":"py/#sys-module","title":"<code>sys</code> Module","text":"<p>The sys module provides access to variables and functions related to Python itself and the operating system it is running on.  you can retrieve the list of modules currently imported using the <code>sys.modules</code> variable, which is a dictionary whose key is the module name you want to inspect and whose returned value is the module object. Calling <code>sys.modules.keys()</code>, for example, will return the complete list of the names of loaded modules.</p> <p>You can also retrieve the list of modules that are built-in by using the <code>sys.builtin_module_names</code> variable. The built-in modules compiled to your interpreter can vary depending on what compilation options were passed to the Python build system.</p>"},{"location":"py/#import-paths","title":"Import Paths","text":"<p>When importing modules, Python relies on a list of paths to know where to look for the module. This list is stored in the <code>sys.path</code> variable.You can change this list, adding or removing paths as necessary, or even modify the <code>PYTHONPATH</code> environment variable. Adding paths to the sys.path variable can be useful if you want to install Python modules to nonstandard locations, such as a test environment. Note that the list will be iterated over to find the requested module, so the order of the paths in <code>sys.path</code> is important.</p> <p>Your current directory is searched before the Python Standard Library directory. That means that if you decide to name one of your scripts <code>random.py</code> and then try using <code>import random</code>, the file from your current directory will be imported rather than the Python module.</p>"},{"location":"py/#useful-standard-libraries","title":"Useful Standard Libraries","text":"<ul> <li><code>atexit</code> allows you to register functions for your program to call when it exits;</li> <li><code>argparse</code> provides functions for parsing command line arguments;</li> <li><code>bisect</code> provides bisection algorithms for sorting lists;</li> <li><code>calendar</code> provides a number of date-related functions;</li> <li><code>codecs</code> provides functions for encoding and decoding data;</li> <li><code>collections</code> provides a variety of useful data structures;</li> <li><code>copy</code> provides functions for copying data;</li> <li><code>csv</code> provides functions for reading and writing CSV files;</li> <li><code>datetime</code> provides classes for handling dates and times;</li> <li><code>fnmatch</code> provides functions for matching Unix-style filename patterns;</li> <li><code>concurrent</code> provides asynchronous computation;</li> <li><code>glob</code> provides functions for matching Unix-style path patterns;</li> <li><code>io</code> provides functions for handling I/O streams. In Python 3, it also contains StringIO, which allows you to treat strings as files;</li> <li><code>json</code> provides functions for reading and writing data in JSON format;</li> <li><code>logging</code> provides access to Python\u2019s own built-in logging functionality;</li> <li><code>multiprocessing</code> allows you to run multiple subprocesses from your application, while providing an API that makes them look like threads;</li> <li><code>operator</code> provides functions implementing the basic Python operators, which you can use instead of having to write your own lambda expressions;</li> <li><code>os</code> provides access to basic OS functions;</li> <li><code>random</code> provides functions for generating pseudorandom numbers;</li> <li><code>re</code> provides regular expression functionality;</li> <li><code>sched</code> provides an event scheduler without using multithreading;</li> <li><code>select</code> provides access to the select() and poll() functions for creating event loops;</li> <li><code>shutil</code> provides access to high-level file functions;</li> <li><code>signal</code> provides functions for handling POSIX signals;</li> <li><code>tempfile</code> provides functions for creating temporary files and directories;</li> <li><code>threading</code> provides access to high-level threading functionality;</li> <li><code>urllib</code> provides functions for handling and parsing URLs;</li> <li><code>uuid</code> allows you to generate Universally Unique Identifiers (UUIDs);</li> </ul>"},{"location":"py/#documentation","title":"Documentation","text":"<p>Your project documentation should always include the following on a <code>README.md</code> file:</p> <ul> <li>The problem your project is intended to solve, in one or two sentences.</li> <li>The license your project is distributed under. If your software is open source, you should also include this information in a header in each code file; just because you\u2019ve uploaded your code to the Internet doesn\u2019t mean that people will know what they\u2019re allowed to do with it.</li> <li>A small example of how your code works.</li> <li>Installation instructions.</li> <li>Links to community support, mailing list, IRC, forums, and so on.</li> <li>A link to your bug tracker system.</li> <li>A link to your source code so that developers can download and start delving into it right away.</li> </ul> <p>Also, it's useful to have a <code>CONTRIBUTING.md</code> file that will be displayed when someone submits a pull request. It should provide a checklist for users to follow before they submit the PR, including things like whether your code follows PEP 8 and reminders to run the unit tests.</p> <p>Some documentation software:</p> <ul> <li>Sphinx reads Markdown (through MyST) or reStructuredText and produces HTML or PDF documentation.</li> <li>mdBook reads Markdown and produces HTML or PDF documentation.</li> </ul>"},{"location":"py/#documenting-api-changes","title":"Documenting API Changes","text":"<p>Whenever you make changes to an API, the first and most important thing to do is to heavily document them so that a consumer of your code can get a quick overview of what\u2019s changing. Your document should cover:</p> <ul> <li>New elements of the new interface</li> <li>Elements of the old interface that are deprecated</li> <li>Instructions on how to migrate to the new interface</li> </ul> <p>Make sure that you don\u2019t remove the old interface right away. I recommend keeping the old interface until it becomes too much trouble to do so. If you have marked it as deprecated, users will know not to use it. Example:</p> <pre><code>class Car(object):\n    def turn_left(self):\n        \"\"\"Turn the car left.\n\n        .. deprecated:: 1.1\n            Use :func:`turn` instead with the direction argument set to left\n        \"\"\"\n        self.turn(direction='left')\n\n    def turn(self, direction):\n        \"\"\"Turn the car in some direction.\n\n        :param direction: The direction to turn to.\n        :type direction: str\n        \"\"\"\n        pass\n</code></pre> <p>Python also provides the warnings module, which allows your code to issue various kinds of warnings when a deprecated function is called. These warnings, <code>DeprecationWarning</code> and <code>PendingDeprecationWarning</code>, can be used to tell the developer that a function they\u2019re calling is deprecated or going to be deprecated, respectively. Example:</p> <pre><code>import warnings\n\nclass Car(object):\n    def turn_left(self):\n        \"\"\"Turn the car left.\n\n        .. deprecated:: 1.1\n            Use :func:`turn` instead with the direction argument set to left\n        \"\"\"\n        warnings.warn(\"turn_left is deprecated; use turn instead\", DeprecationWarning)\n        self.turn(direction='left')\n\n    def turn(self, direction):\n        \"\"\"Turn the car in some direction.\n\n        :param direction: The direction to turn to.\n        :type direction: str\n        \"\"\"\n        pass\n</code></pre> <p>Python 2.7 and later versions, by default, do not print any warnings emitted by the warnings module.The option -W all will print all warnings to <code>stderr</code>, which can be a good way to catch warnings and fix them early on when running a test suite. Debtcollector can automate some of this.</p>"},{"location":"py/#diataxis","title":"Di\u00e1taxis","text":"<p>TODO</p>"},{"location":"py/#generating-documentation-from-docstrings","title":"Generating Documentation from Docstrings","text":"<p>TODO</p>"},{"location":"py/#doctesting","title":"Doctesting","text":"<p>TODO</p>"},{"location":"py/#release-engineering","title":"Release Engineering","text":"<p>PyPA recommends Setuptools to package Python software. For what is worth, I recommend Poetry.</p>"},{"location":"py/#poetry","title":"Poetry","text":"<p>TODO</p>"},{"location":"py/#tox","title":"Tox","text":"<p>TODO</p>"},{"location":"py/#the-abstract-syntax-tree","title":"The Abstract Syntax Tree","text":"<p>TODO</p>"},{"location":"py/#numpy","title":"Numpy","text":"<p>Basic functions:</p> <pre><code>import numpy as np\n\n# Creating arrays\nnp.array([1000, 2300, 4987, 1500])    # Create array from list: array([1000, 2300, 4987, 1500])\nnp.arange(10)    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nnp.arange(10, 25, 5)    # array([10, 15, 20])\nnp.loadtxt(fname='file.txt', dtype=int)    # Creates an array of ints with the contents of file.txt\nnp.zeros((m, n))    # Create an array of zeros with shape (m, n)\nnp.ones((m, n),dtype=np.int16)    # Create an array of ones with shape (m, n) and type dtype\nnp.linspace(0,2,9)    # Create an array of evenly spaced values: array([0., 0.25, 0.5 , 0.75, 1., 1.25, 1.5, 1.75, 2.])\nnp.full((m, n), a)    # Create an array with shape (m, n) whose elements are always a\nnp.eye(m)    # Create an identity matrix with dimension m\nnp.random.random((m, n))    # Create a random matrix with dimension (m, n). Random numbers between 0 and 1\nnp.empty((m, n))    # Create an empty array with dimension (m, n). The data is garbage.\n\n# Attributes\ndata_array.dtype    # Returns the type of the elements of data_array\ndata_array.shape    # Returns the dimensions of the array\ndata_array.ndim    # Returns the number of dimensions of the array\ndata_array.size    # Returns the number of elements of the array\n</code></pre> <p>Operations with floats and integers broadcast to the whole array:</p> <pre><code>a = np.ones(4, dtype=int)\na/2\n# &gt;&gt;&gt; array([0.5, 0.5, 0.5, 0.5])\n</code></pre> <p>Selecting data:</p> <pre><code>a = np.random.random((2, 2))\na[1, 1]    # Returns the element on the second line and second column\na[-1]    # Returns the last line\n\nb = np.random.random((10))\nb[1:4]    # Returns the elements with index 1, 2 and 3\n# The syntax is array[min:max:step]. min is 0 by default, max is not included.\nb[:4:2]    # Returns the elements with index 0 and 2\n\nc = np.random.random((10, 10))\nc[:, 1:3]    # Returns the columns 1 and 2 of all the lines\nc[:4, ::2]    # Returns the first 4 lines (indexes 0, 1, 2 and 3) with columns jumped by 2 (indexes 0, 2, 4, 6, 8)\n</code></pre> <p>Verifying conditions:</p> <pre><code>a = np.random.random((4))\na &gt; 1    # Returns a boolean array: array([False, False, False, False])\na[a &gt; 0.5]    # Returns an array containing all numbers that obey the condition\n</code></pre> <p>Some methods:</p> <pre><code>a.T    # Returns the transpose of the array\na.tolist()    # Converts the array to a list\na.reshape((m, n), order='C')    # Reorganizes the array into a new array with dimensions (m, n)\n\n# Example:\na = np.arange(10)\na.reshape((5, 2), order='C')    # &gt;&gt;&gt; array([[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]])\na.reshape((5, 2), order='F')    # &gt;&gt;&gt; array([[0, 5], [1, 6], [2, 7], [3, 8], [4, 9]])\n\n# array + array is element-wise sum of arrays\n# list + list is concatenation of lists\n\nnp.column_stack((a, b, c))    # Take a tuple of 1D arrays and stack them as columns to make a single 2D array.\nnp.sum(a[:,2])    # Returns the sum of all the elements of the slice\n</code></pre> <p>Some basic statistics:</p> <pre><code>np.mean(a)    # Returns the mean of all the elements of the array\nnp.mean(a[:, 2])    # Returns the mean of all the elements of the slice\nnp.mean(a, axis=0)    # Returns the mean of all the elements of the array in the axis 0\n\nnp.std(a[:,2])    # Returns the standard deviation of the slice\n</code></pre>"},{"location":"py/#bibliography","title":"Bibliography","text":"<ul> <li>Julien Danjou. Serious Python. No Starch Press, 2019.</li> </ul>"},{"location":"rust/","title":"Notes on Rust","text":""},{"location":"rust/#basics","title":"Basics","text":"<p>Rust's philosophy:</p> <ul> <li>Strictly enforcing safe borrowing of data</li> <li>Functions, methods and closures to operate on data</li> <li>Tuples, structs and enums to aggregate data</li> <li>Pattern matching to select and destructure data</li> <li>Traits to define behavior on data</li> </ul> <pre><code>// Hello world\nfn main() {\n    println!(\u201cHello!\u201d);\n}\n</code></pre> <p>Functions to write strings:</p> <ul> <li><code>format!</code>: write formatted text to String</li> <li><code>print!</code>: same as format! but the text is printed to the console (io::stdout).</li> <li><code>println!</code>: same as print! but a newline is appended.</li> <li><code>eprint!</code>: same as format! but the text is printed to the standard error (io::stderr).</li> <li><code>eprintln!</code>: same as eprint! but a newline is appended.</li> </ul> <p>Ways to print to stdout:</p> <pre><code>fn main() {\n    println!(\u201cToday is {}\u201d, 20);\n\n    // By variable\n    let name = \"world\";\n    println!(\"Hello {name}!\");\n\n    // By positional argument\n    println!(\"{0}, this is {1}. {1}, this is {0}\", \"Alice\", \"Bob\");\n\n    // By naming the arguments\n    println!(\"{subject} {verb} {object}\", object=\"the lazy dog\",subject=\"the quick brown fox\", verb=\"jumps over\");\n\n    // By right-aligning a text with a specified width\n    println!(\"{number:&gt;width$}\", number=1, width=6);\n\n    // By padding numbers with extra zeroes\n    println!(\"{number:&gt;0width$}\", number=1, width=6);\n\n    // By rounding floats\n    let pi = 3.141592;\n    println!(\"Pi is roughly {:.3}\", pi);\n}\n</code></pre> <p>Tests:</p> <pre><code>fn main() {\n    // Checks if x is equal to y. If not, panic.\n    assert_eq!(x, y);\n\n    // Checks if x is not equal to y. If not, panic.\n    assert_neq!(x, y);\n\n    // Checks if expression is true. If not, panic.\n    assert!(expression);\n}\n</code></pre> <p>Commentaries:</p> <pre><code>fn main() {\n    // Regular commentary.\n\n    /*\n        Multi-line\n        Commentary\n    */\n\n    /// Commentary that will become documentation with cargo doc --open\n    /// It accepts markdown\n    /// And can contain tests:\n    ///\n    /// ```\n    /// use my_lib::*;\n    ///\n    /// assert_eq!(3, soma(1, 2));\n    /// ```\n    pub fn soma(x: i32, y: i32) -&gt; i32\n    {\n        x + y\n    }\n}\n</code></pre> <p>The build system and dependency manager is called cargo:</p> <pre><code># Creates a new project\ncargo new [name]\n\n# Create a new project without git\ncargo new --vcs=none [name]\n\n# Compiles\ncargo build\n\n# Compiles with optimizations\ncargo build --release\n\n# Checks for syntax errors\ncargo check\n\n# Compiles and executes\ncargo run\n\n# Updates the dependencies. Doesn't bump major version\ncargo update\n\n# Creates documentation\ncargo doc --open\n\n# Linting\ncargo fmt\ncargo fix\ncargo clippy\n</code></pre> <p>You can make Clippy pedantic by adding the following at the first line of the <code>main.rs</code> file:</p> <pre><code>#![warn(clippy::all, clippy::pedantic)]\n</code></pre> <p>Declaration of variables:</p> <pre><code>fn main() {\n    // Immutable variable\n    let a = 1;\n\n    // Mutable variable\n    let mut b = 2;\n\n    // Constant with type annotation\n    const CTE: u32 = 100;\n\n    // It is possible to do shadowing. The final value o x is 6\n    let x = 5;\n    let x = x + 1;\n}\n</code></pre> <p>For integers, we have <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> and <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> for unsigned. For floats, <code>f32</code> and <code>f64</code>. <code>i32</code> and <code>f64</code> are the default types. The usual operators are present: <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> The underscore <code>_</code> means to throw away something:</p> <pre><code>// this does nothing because 42 is a constant\nlet _ = 42;\n\n// this calls `get_thing` but throws away its result\nlet _ = get_thing();\n\n// Starting with an underscore means the compiler  won't warn about them being unused:\nlet _x = 42;\n</code></pre> <p>Tuples:</p> <pre><code>fn main() {\n    // Doesn't grow in size\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\n\n    // Destructuring\n    let (x, y, z) = tup;\n    println!(\"The value of y is: {}\", y);\n\n    // Destructuring only a part of it\n    let (_, _, one) = tup;\n\n    // By index\n    let five_hundred = tup.0;\n}\n</code></pre> <p>Arrays:</p> <pre><code>fn main() {\n    // Doesn't grow in size. All elements of the same type.\n    let a = [1, 2, 3, 4, 5];\n    let first = a[0];\n\n    // Creates an array of 5 elements, each of which is 3\n     let a = [3; 5];\n}\n</code></pre> <p>Structs:</p> <pre><code>// Declaration\nstruct Vec2 {\n    x: f64,\n    y: f64,\n}\n\n// Initialization\n// The order does not matter, only the names do\nlet v1 = Vec2 { x: 1.0, y: 3.0 };\nlet v2 = Vec2 { y: 2.0, x: 4.0 };\n\n// Initializing the rest of the fields from another struct\nlet v3 = Vec2 { x: 14.0, ..v2 };\nlet v4 = Vec2 { ..v3 };\n\n// Destructuring\n// `x` is now 1.0, `y` is now `3.0`\nlet Vec2 { x, y } = v1;\n\n// This throws away `v.y`\nlet Vec2 { x, .. } = v;\n\n// A tuple struct\nstruct Point2D(u32, u32);\n\n// A unit struct\nstruct Unit;\n</code></pre> <p>Tuple structs are similar to classic structs, but their fields have no names. For accessing individual variables, the same syntax is used as with regular tuples, namely, foo.0, foo.1, and so on, starting at zero. Unit structs are most commonly used as markers. They're useful when you need to implement a trait on something but don't need to store any data inside it.</p> <pre><code>fn main() {\n    // Instantiate a classic struct, with named fields. Order does not matter.\n    let person = Person {\n        name: String::from(\"Adam\"),\n        likes_oranges: true,\n        age: 25\n    };\n\n    // Instantiate a tuple struct by passing the values in the same order as defined.\n    let origin = Point2D(0, 0)\n\n    // Instantiate a unit struct.\n    let unit = Unit;\n}\n</code></pre> <p>Functions:</p> <pre><code>fn my_function(arg1: type1, arg2: type2) -&gt; return_type\n{\n\u200b   //body\n}\n</code></pre> <p>You can declare methods on your own types:</p> <pre><code>struct Number {\n    odd: bool,\n    value: i32,\n}\n\nimpl Number {\n    fn is_strictly_positive(self) -&gt; bool {\n        self.value &gt; 0\n    }\n}\n</code></pre> <p>Traits are something multiple types can have in common. You can implement:</p> <ul> <li>One of your traits on anyone's type</li> <li>Anyone's trait on one of your types</li> <li>But not a foreign trait on a foreign type</li> </ul> <pre><code>struct Number {\n    odd: bool,\n    value: i32,\n}\n\ntrait Signed {\n    fn is_strictly_negative(self) -&gt; bool;\n}\n\n// Our trait on our type\nimpl Signed for Number {\n    fn is_strictly_negative(self) -&gt; bool {\n        self.value &lt; 0\n    }\n}\n\n// Our trait on a foreign type\nimpl Signed for i32 {\n    fn is_strictly_negative(self) -&gt; bool {\n        self &lt; 0\n    }\n}\n\n// A foreign trait on our type:\n// The `Neg` trait is used to overload `-`, the unary minus operator.\n// An impl block is always for a type, so, inside that block, Self means that type.\nimpl std::ops::Neg for Number {\n    type Output = Self;\n\n    fn neg(self) -&gt; Self {\n        Self {\n            value: -self.value,\n            odd: self.odd,\n        }\n    }\n}\n</code></pre> <p>Some traits are markers - they don't say that a type implements some methods, they say that certain things can be done with a type:</p> <pre><code>fn main() {\n    // i32 implements trait Copy (in short, i32 is Copy):\n    let a: i32 = 15;\n    let b = a; // `a` is copied\n    let c = a; // `a` is copied again\n    print_i32(a); // `a` is copied again\n\n    // The Number struct is not Copy, so this doesn't work:\n    let n = Number { odd: true, value: 51 };\n    let m = n; // `n` is moved into `m`\n    let o = n; // error: use of moved value: `n`\n\n    // It works if print_number takes an immutable reference instead:\n    print_number(&amp;n); // `n` is borrowed for the time of the call\n    print_number(&amp;n); // `n` is borrowed again\n\n    // It also works if a function takes a mutable reference - but only if our variable binding is also mut:\n    let mut m = Number { odd: true, value: 51 };\n    print_number(&amp;m);\n    invert(&amp;mut m); // `m is borrowed mutably - everything is explicit\n    print_number(&amp;m);\n}\n\nfn print_i32(x: i32) {\n    println!(\"x = {}\", x);\n}\n\nfn print_number(n: &amp;Number) {\n    println!(\"{} number {}\", if n.odd { \"odd\" } else { \"even\" }, n.value);\n}\n\nfn invert(n: &amp;mut Number) {\n    n.value = -n.value;\n}\n</code></pre> <p>Trait methods can also take self by reference or mutable reference:</p> <pre><code>impl std::clone::Clone for Number {\n    fn clone(&amp;self) -&gt; Self {\n        Self { ..*self }\n    }\n}\n\n// Marker traits like Copy have no methods:\n// `Copy` requires that `Clone` is implemented too.\n// Number values will no longer be moved, but copied.\nimpl std::marker::Copy for Number {}\n</code></pre> <p>When invoking trait methods, the receiver is borrowed implicitly:</p> <pre><code>fn main() {\n    let n = Number { odd: true, value: 51 };\n    let mut m = n.clone();\n    m.value += 100;\n\n    print_number(&amp;n);\n    print_number(&amp;m);\n}\n</code></pre> <p>Some traits are so common, they can be implemented automatically by using the derive attribute:</p> <pre><code>#[derive(Clone, Copy)]\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n</code></pre> <p>Functions can be generic:</p> <pre><code>fn foobar&lt;T&gt;(arg: T) {\n    // do something with `arg`\n}\n\n// Multiple type parameters:\nfn foobar&lt;L, R&gt;(left: L, right: R) {\n    // do something with `left` and `right`\n}\n</code></pre> <p>Type parameters can have constraints:</p> <pre><code>fn print&lt;T: Display&gt;(value: T) {\n    println!(\"value = {}\", value);\n}\n\nfn print&lt;T: Debug&gt;(value: T) {\n    println!(\"value = {:?}\", value);\n}\n\n// Longer syntax:\nfn print&lt;T&gt;(value: T)\nwhere\n    T: Display,\n{\n    println!(\"value = {}\", value);\n}\n\n// If you want multiple constraints:\nuse std::fmt::Debug;\n\nfn compare&lt;T&gt;(left: T, right: T)\nwhere\n    T: Debug + PartialEq,\n{\n    println!(\"{:?} {} {:?}\", left, if left == right { \"==\" } else { \"!=\" }, right);\n}\n\nfn main() {\n    compare(\"tea\", \"coffee\"); // prints: \"tea\" != \"coffee\"\n}\n</code></pre> <p>Generic functions can be navigated using <code>::</code></p> <pre><code>fn main() {\n    use std::any::type_name;\n\n    // Turbofish syntax\n    println!(\"{}\", type_name::&lt;i32&gt;()); // prints \"i32\"\n    println!(\"{}\", type_name::&lt;(f64, char)&gt;()); // prints \"(f64, char)\"\n}\n</code></pre> <p>Structs can be generic:</p> <pre><code>struct Pair&lt;T&gt; {\n    a: T,\n    b: T,\n}\n\nfn print_type_name&lt;T&gt;(_val: &amp;T) {\n    println!(\"{}\", std::any::type_name::&lt;T&gt;());\n}\n\nfn main() {\n    let p1 = Pair { a: 3, b: 9 };\n    let p2 = Pair { a: true, b: false };\n    print_type_name(&amp;p1); // prints \"Pair&lt;i32&gt;\"\n    print_type_name(&amp;p2); // prints \"Pair&lt;bool&gt;\"\n\n    // Vec is generic\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n}\n</code></pre> <p>Enums are types that can only have some specific values</p> <pre><code>fn main() {\n    enum WebEvent {\n    // An `enum` may either be `unit-like`,\n    PageLoad,\n    PageUnload,\n\n    // like tuple structs,\n    KeyPress(char),\n    Paste(String),\n\n    // or c-like structures.\n    Click { x: i64, y: i64 },\n    }\n}\n</code></pre> <p>Vectors:</p> <pre><code>fn main() {\n    // Vec is generic\n    let mut v1 = Vec::new();\n    v1.push(1);\n    let mut v2 = Vec::new();\n    v2.push(false);\n\n    // Literals:\n    let v1 = vec![1, 2, 3];\n    let v2 = vec![true, false, true];\n}\n</code></pre> <p>Hash maps:</p> <p>The type <code>HashMap&lt;K, V&gt;</code> stores a mapping of keys of type K to values of type V.</p> <pre><code>fn main() {\n    use std::collections::HashMap;\n\n    let mut contacts = HashMap::new();\n\n    contacts.insert(\"Daniel\", \"798-1364\");\n    contacts.insert(\"Ashley\", \"645-7689\");\n    contacts.insert(\"Katie\", \"435-8291\");\n    contacts.insert(\"Robert\", \"956-1745\");\n\n    // Search for \"Daniel\" on contacts\n    match contacts.get(&amp;\"Daniel\") {\n        Some(&amp;number) =&gt; println!(\"Calling Daniel: {}\", call(number)),\n        _ =&gt; println!(\"Don't have Daniel's number.\"),\n    }\n\n    // Remove \"Ashley\" from contacts\n    contacts.remove(&amp;\"Ashley\");\n\n    // `HashMap::iter()` returns an iterator that yields\n    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.\n    for (contact, &amp;number) in contacts.iter() {\n        println!(\"Calling {}: {}\", contact, call(number));\n    }\n}\n</code></pre> <p>Conditional:</p> <pre><code>if number % 4 == 0 {\n    println!(\"number is divisible by 4\");\n} else if number % 3 == 0 {\n    println!(\"number is divisible by 3\");\n} else if number % 2 == 0 {\n    println!(\"number is divisible by 2\");\n} else {\n    println!(\"number is not divisible by 4, 3, or 2\");\n}\n\nlet number = if condition {\n    5\n} else {\n    6\n};\n</code></pre> <p>Match:</p> <pre><code>// Similar to switch in C, but more powerful\nmatch feeling_lucky {\n    true =&gt; 6,\n    false =&gt; 4,\n}\n\n/*******************************************************/\nstruct Number {\n    odd: bool,\n    value: i32,\n}\n\nfn main() {\n    let one = Number { odd: true, value: 1 };\n    let two = Number { odd: false, value: 2 };\n    print_number(one);\n    print_number(two);\n}\n\nfn print_number(n: Number) {\n    match n {\n        Number { odd: true, value } =&gt; println!(\"Odd number: {}\", value),\n        Number { odd: false, value } =&gt; println!(\"Even number: {}\", value),\n    }\n}\n\n/*******************************************************/\n// A match has to be exhaustive: at least one arm needs to match.\nfn print_number(n: Number) {\n    match n {\n        Number { value: 1, .. } =&gt; println!(\"One\"),\n        Number { value: 2, .. } =&gt; println!(\"Two\"),\n        Number { value, .. } =&gt; println!(\"{}\", value),\n        // If the last arm didn't exist, we would get a compile-time error\n    }\n}\n\n/*******************************************************/\n// _ can be used as a \"catch-all\" pattern:\nfn print_number(n: Number) {\n    match n.value {\n        1 =&gt; println!(\"One\"),\n        2 =&gt; println!(\"Two\"),\n        _ =&gt; println!(\"{}\", n.value),\n    }\n}\n</code></pre> <p>Loop:</p> <pre><code>// Infinite loop\nloop {\n    // body\n}\n\n// result is 20\nlet result = loop {\n    counter += 1;\n    if counter == 10 {\n        break counter * 2;\n    }\n};\n\nwhile number != 0 {\n    println!(\"{}!\", number);\n    number -= 1;\n}\n\nlet a = [10, 20, 30, 40, 50];\nfor element in a.iter() {\n    println!(\"the value is: {}\", element);\n}\n\nfor number in (1..4).rev() {\n    println!(\"{}!\", number);\n}\n</code></pre> <p>A pair of brackets declares a block, which has its own scope:</p> <pre><code>// This prints \"in\", then \"out\"\nfn main() {\n    let x = \"out\";\n    {\n        // this is a different `x`\n        let x = \"in\";\n        println!(x);\n    }\n    println!(x);\n}\n</code></pre> <p>Blocks are also expressions, which mean they evaluate to a value.</p> <pre><code>// This:\nlet x = 42;\n\n// Is equivalent to this:\nlet x = { 42 };\n</code></pre> <p>Inside a block, there can be multiple statements:</p> <pre><code>let x = {\n    let y = 1; // First statement\n    let z = 2; // Second statement\n    y + z // This is the tail - what the whole block will evaluate to\n};\n</code></pre> <p>That's why \"omitting the semicolon at the end of a function\" is the same as returning.</p>"},{"location":"rust/#importing-and-namespaces","title":"Importing and Namespaces","text":"<p><code>use</code> directives can be used to \"bring in scope\" names from other namespace:</p> <pre><code>// std is a crate (~ a library), cmp is a module (~ a source file), and\n// min is a function:\n\nuse std::cmp::min;\nlet least = min(7, 1); // This is 1\n</code></pre> <p>Within use directives, curly brackets have another meaning: they're globs\". If we want to import both min and max , we can do any of these:</p> <pre><code>// this works:\nuse std::cmp::min;\nuse std::cmp::max;\n\n// this also works:\nuse std::cmp::{min, max};\n\n// this also works!\nuse std::{cmp::min, cmp::max};\n</code></pre> <p>A wildcard ( * ) lets you import every symbol from a namespace:</p> <pre><code>// This brings `min` and `max` in scope, and many other things\nuse std::cmp::*;\n</code></pre>"},{"location":"rust/#panic-options-and-result","title":"Panic, Options and Result","text":"<pre><code>// Is a macro that violently stops execution with an error message, and the file name / line number of the error\npanic!(\"Error message\");\n\n// Option is a type that contains something, or nothing. If .unwrap() is called on it, and it contains nothing, it panics\nenum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n\nlet o1: Option&lt;i32&gt; = Some(128);\no1.unwrap(); // this is fine\n\nlet o2: Option&lt;i32&gt; = None;\no2.unwrap(); // this panics!\n\n// Result is an enum that can either contain something, or an error. It also panics when unwrapped and containing an error\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\n// get returns an option with the value if the index is inside of bounds\nlet fruits = vec![\"banana\", \"apple\", \"coconut\", \"orange\", \"strawberry\"];\n    for index in 0..10 {\n        match fruits.get(index) {\n            Some(fruit_name) =&gt; println!(\"It's a delicious {}!\", fruit_name),\n            None =&gt; println!(\"There is no fruit! :(\"),\n        }\n    }\n\nlet number = Some(7);\n// The `if let` construct reads: \"if `let` destructures `number` into\n// `Some(i)`, evaluate the block (`{}`).\nif let Some(i) = number {\n    println!(\"Matched {:?}!\", i);\n}\n</code></pre>"},{"location":"rust/#lifetime","title":"Lifetime","text":"<p>Variables have lifetimes:</p> <pre><code>fn main() {\n    // `x` doesn't exist yet\n    {\n        // `x` starts existing\n        let x = 42;\n\n        // `x_ref` starts existing - it borrows `x`\n        let x_ref = &amp;x;\n\n        println!(\"x = {}\", x);\n\n        // `x_ref` stops existing\n        // `x` stops existing\n    }\n    // `x` no longer exists\n}\n</code></pre> <p>The lifetime of a reference cannot exceed the lifetime of the variable binding it borrows:</p> <pre><code>fn main() {\n    let x_ref = {\n        let x = 42;\n        &amp;x\n    };\n    println!(\"x_ref = {}\", x_ref);\n    // error: `x` does not live long enough\n}\n</code></pre>"},{"location":"rust/#memory","title":"Memory","text":""},{"location":"rust/#stack-and-heap","title":"Stack and Heap","text":"<p>Both the stack and the heap are parts of memory that are available to your code to use at runtime, but they are structured in different ways. The stack is last in, first out. Adding data is called pushing onto the stack, and removing data is called popping off the stack. All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer. Pushing to the stack is faster than allocating on the heap because the operating system never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work, because the operating system must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation. When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function\u2019s local variables get pushed onto the stack. When the function is over, those values get popped off the stack. The stack is the memory set aside as scratch space for a thread of execution. When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer. The heap is memory set aside for dynamic allocation. Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns. Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation). The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application. The stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits. The size of the stack is set when a thread is created. The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system). The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with \"all\" other heap accesses in the program.</p>"},{"location":"rust/#ownership","title":"Ownership","text":"<p>Each value in Rust has a variable that\u2019s called its owner. There can only be one owner at a time. When the owner goes out of scope, the value will be dropped. Copies of heap objects are shallow, meaning that a new variable is just another pointer (on the stack) to the same heap address. The first pointer becomes stale.</p> <pre><code>let s1 = String::from(\"Hello!\");\nlet s2 = s1;\n</code></pre> <p>Stack variables are deep copied. They have a fixed size known in compile time.  As a general rule, any group of simple scalar values can be Copy, and nothing that requires allocation or is some form of resource is Copy. Ex.: integers, floats, booleans, characters and tuples of these types. Passing a variable to a function will move or copy, just as assignment does:</p> <pre><code>fn main() {\n    // s comes into scope\n    let s = String::from(\"hello\");\n\n    // s's value moves into the function and so is no\n    // longer valid here\n    takes_ownership(s);\n\u200b\n    // x comes into scope\n    let x = 5;\n\u200b\n    // x would move into the function, but i32 is Copy,\n    // so it\u2019s okay to still use x afterward\n    makes_copy(x);\n}\n// Here, x goes out of scope, then s. But because s's\n// value was moved, nothing special happens.\n\nfn takes_ownership(some_string: String) {\n\u200b    // some_string comes into scope\n    println!(\"{}\", some_string);\n}\u200b\n// Here, some_string goes out of scope and `drop` is\n// called. The backing memory is freed.\n\nfn makes_copy(some_integer: i32) {\n    // some_integer comes into scope\n    println!(\"{}\", some_integer);\n}\n// Here, some_integer goes out of scope. Nothing\n// special happens.\n</code></pre> <p>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless the data has been moved to be owned by another variable. At any given time, you can have either one mutable reference or any number of immutable references. References must always be valid.</p>"},{"location":"rust/#references","title":"References","text":"<ul> <li>Rust Book</li> <li>A Half Hour to Learn Rust</li> </ul>"},{"location":"sysadmin/","title":"Notes on System Administration","text":""},{"location":"sysadmin/#users","title":"Users","text":"<ul> <li><code>passwd [options] [user]</code>: changes passwords for user accounts. A normal user may only change the password for their own account, while the superuser may change the password for any account. It also changes the account or associated password validity period.</li> <li><code>su [options] [-] [user]</code>: allows commands to be run with a substitute user and group ID. <code>-</code> starts the shell as a login shell. <code>-c command</code> passes a command.</li> </ul>"},{"location":"sysadmin/#file-system","title":"File System","text":""},{"location":"sysadmin/#filesystem-hierarchy-standard","title":"Filesystem Hierarchy Standard","text":"<ul> <li><code>bin</code>: Essential command binaries</li> <li><code>boot</code>: Static files of the boot loader</li> <li><code>dev</code>: Device files</li> <li><code>etc</code>: Host-specific system configuration</li> <li><code>home</code>: Users directories</li> <li><code>lib</code>: Essential shared libraries and kernel modules</li> <li><code>media</code>: Mount point for removable media</li> <li><code>mnt</code>: Mount point for mounting a filesystem temporarily</li> <li><code>opt</code>: Add-on application software packages</li> <li><code>proc</code>: Kernel and process file system</li> <li><code>root</code>: Home directory for the root user</li> <li><code>run</code>: Data relevant to running processes</li> <li><code>sbin</code>: Essential system binaries</li> <li><code>srv</code>: Data for services provided by this system</li> <li><code>sys</code>: Kernel and system information</li> <li><code>usr/bin</code>: Most user commands</li> <li><code>usr/include</code>: Standard header files</li> <li><code>usr/lib</code>: Libraries for programming and packages</li> <li><code>usr/libexec</code>: Binaries run by other programs</li> <li><code>usr/local</code>: Local software</li> <li><code>usr/share</code>: Arch independent data</li> <li><code>tmp</code>: Temporary files</li> <li><code>var</code>: Variable data</li> <li><code>var/spool/cron</code>: Cron jobs' data</li> </ul>"},{"location":"sysadmin/#commands","title":"Commands","text":"<ul> <li><code>cmp [options] [file1] [file2]</code>: compare two files byte by byte.</li> <li><code>find [options] [start directory] -name [pattern]</code>: searches for files.</li> <li><code>plocate [pattern]</code>: searches for files. <code>sudo updatedb</code> to update its database.</li> <li><code>tree [options] [directory]</code>: a recursive directory listing program that produces a depth indented listing of files. <code>-L</code> sets the max display depth of the directory tree.</li> <li><code>cp [options] [origin] [destination]</code>: copy from <code>origin</code> to <code>destination</code>. <code>-i</code> asks before copying. <code>-r</code> recursive copy. <code>-t folder</code> copy everything from origin into folder. <code>-T</code> destination is a file.</li> <li><code>mv [options] [origin] [destination]</code>: move/rename from <code>origin</code> to <code>destination</code>. <code>-i</code> asks before moving. <code>-t folder</code> move everything from origin into folder. <code>-T</code> destination is a file.</li> <li><code>rm [options] [file]</code>: remove/rename <code>file</code>. <code>-i</code> asks before removing. <code>-r</code> recursive remove.</li> <li><code>ln -s [origin] [destination]</code>: soft link from <code>origin</code> to <code>destination</code>.</li> </ul>"},{"location":"sysadmin/#permissions","title":"Permissions","text":"<ul> <li><code>d rwx rwx rwx</code>: if directory and read, write, execute for user, group and others</li> <li><code>groups [user]</code>: list the groups the user is a member of</li> <li><code>chgrp [options] [group] [file]</code>: change the group of the file</li> <li><code>chown [options] [user] [file]</code>: change the user of the file</li> <li><code>chmod u=rwx,g=rx,o=r [file]</code>: change the permissions of the file to the exact ones provided</li> <li><code>chmod u+wx [file]</code>: add permissions to the file</li> <li><code>chmod ug-wx [file]</code>: remove permissions from the file</li> </ul>"},{"location":"sysadmin/#shell","title":"Shell","text":""},{"location":"sysadmin/#wildcards","title":"Wildcards","text":"<p>Wildcards are placeholders for omitted letters or numbers:</p> <ul> <li><code>?</code>: placeholder for one character</li> <li><code>*</code>: placeholder for zero or more characters</li> </ul> <pre><code>$ ls k?d*\n\nkidder.txt kiddo kidnews kidneypie\n</code></pre>"},{"location":"sysadmin/#commands_1","title":"Commands","text":"<ul> <li><code>chsh [-s shell] [user]</code>: change users shell. <code>-l</code> lists installed shells.</li> </ul>"},{"location":"sysadmin/#variables","title":"Variables","text":"<ul> <li><code>$SHELL</code>: path to current shell binary</li> <li><code>export VAR=MyVar</code>: new env variavle for current session</li> </ul>"},{"location":"sysadmin/#system-information","title":"System Information","text":"<ul> <li><code>uname -a</code>: info on system</li> <li><code>df -h</code>: see all file systems</li> <li><code>du -h</code>: disk usage of files on current directory</li> <li><code>lsblk</code>: list block devices</li> <li><code>lsblk</code>: list block devices</li> <li><code>file [file]</code>: query what kind of file is it</li> <li><code>who [options]</code>: print logged users</li> <li><code>w</code>: print logged users and processes</li> <li><code>id [user]</code>: get user id</li> <li><code>set</code>: print all env variables</li> </ul>"},{"location":"sysadmin/#environment","title":"Environment","text":"<p>TODO</p>"},{"location":"sysadmin/#internet","title":"Internet","text":"<p>TODO</p>"},{"location":"sysadmin/#utilities","title":"Utilities","text":"<ul> <li><code>apropos [options] [keyword]</code>: searches for <code>keyword</code> on manpages</li> <li><code>wc [options] [file]</code>: prints metrics from file. <code>-c</code>counts bytes, <code>-m</code> counts chars, <code>-l</code> counts lines, <code>-w</code> counts words.</li> <li><code>head [-n] [file]</code>: prints the first n lines of file</li> <li><code>tail [-n] [file]</code>: prints the last n lines of file</li> <li><code>grep [options] [pattern] [file]</code>: print lines that match pattern on file. If file is <code>-</code>, stdin is considered. <code>-c</code> just counts matches. <code>v</code> consider non matches</li> <li><code>sed 's/old/new/g' [file]</code>: replace all the occurrence of the pattern on the file</li> <li><code>awk -F, \u2018{ print $2 \u201c \u201c $1 \u201c \u201c $7 }\u2019 [file]</code>: print fields 2, 1 and 7 of file considering a comma delimited file</li> <li><code>sdiff -s [file1] [file2]</code>: prints the comparison of file1 and file2. <code>&lt;</code> if the line exists only in the first file, <code>&gt;</code> if the line exists only in the second file, <code>|</code> if they are different</li> <li><code>sort [options] [files...]</code>: sort lines of text files. <code>-t char</code> char delimited files, <code>+n</code> sort by the nth field, <code>-n</code> sort numerically</li> <li><code>uniq [options] [input] [output]</code>: report or omit repeated lines. <code>-u</code> print unique lines, <code>-D</code> print duplicate lines</li> <li><code>tee [file]</code>: read from standard input and write to standard output and file. <code>-a</code> append, do not overwrite.</li> <li><code>split [options] [size] [file] [prefix]</code>: output pieces of file to PREFIXaa, PREFIXab, ... in chunks of size size. <code>-b</code> size in bytes, <code>-l</code> size in lines, <code>-t char</code> use char as separator</li> <li><code>at [options]</code>: o</li> </ul>"},{"location":"sysadmin/#vim","title":"Vim","text":"<p>TODO</p>"},{"location":"sysadmin/#regular-expressions","title":"Regular Expressions","text":"<p>TODO</p>"}]}